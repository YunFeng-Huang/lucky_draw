!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var r in n)("object"==typeof exports?exports:e)[r]=n[r]}}(this,(function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="dev/",n(n.s=10)}([function(e,t){if(!window.Hilo3d)throw Error("hilo3d not imported");e.exports=window.Hilo3d,Hilo3d.GeometryData.prototype.setSubData||(Hilo3d.GeometryData.prototype.setSubData=function(e,t){this.isDirty=!0,this.data.set(t,e)})},function(e,t,n){"use strict";var r;n.r(t),n.d(t,"RENDER_MODE_BILLBOARD",(function(){return i})),n.d(t,"RENDER_MODE_VERTICAL_BILLBOARD",(function(){return a})),n.d(t,"RENDER_MODE_HORIZONTAL_BILLBOARD",(function(){return o})),n.d(t,"RENDER_MODE_MESH",(function(){return u})),n.d(t,"BLEND_MODE_ADDITIVE",(function(){return f})),n.d(t,"BLEND_MODE_ALPHA",(function(){return s})),n.d(t,"BLEND_MODE_MULTIPLY",(function(){return l})),n.d(t,"BLEND_MODE_LUMINANCE_ALPHA",(function(){return c})),n.d(t,"BLEND_MODE_SUBTRACT",(function(){return d})),n.d(t,"PARTICLE_ORIGIN_CENTER",(function(){return v})),n.d(t,"PARTICLE_ORIGIN_LEFT_TOP",(function(){return m})),n.d(t,"PARTICLE_ORIGIN_LEFT_CENTER",(function(){return _})),n.d(t,"PARTICLE_ORIGIN_LEFT_BOTTOM",(function(){return E})),n.d(t,"PARTICLE_ORIGIN_CENTER_TOP",(function(){return p})),n.d(t,"PARTICLE_ORIGIN_CENTER_BOTTOM",(function(){return h})),n.d(t,"PARTICLE_ORIGIN_RIGHT_TOP",(function(){return y})),n.d(t,"PARTICLE_ORIGIN_RIGHT_CENTER",(function(){return R})),n.d(t,"PARTICLE_ORIGIN_RIGHT_BOTTOM",(function(){return C})),n.d(t,"END_BEHAVIOR_DESTROY",(function(){return T})),n.d(t,"END_BEHAVIOR_PAUSE",(function(){return g})),n.d(t,"END_BEHAVIOR_FORWARD",(function(){return x})),n.d(t,"END_BEHAVIOR_PAUSE_AND_DESTROY",(function(){return O})),n.d(t,"FILTER_NAME_NONE",(function(){return V})),n.d(t,"RENDER_LEVEL_B_PLUS",(function(){return L})),n.d(t,"RENDER_LEVEL_B",(function(){return A})),n.d(t,"RENDER_LEVEL_A_PLUS",(function(){return N})),n.d(t,"RENDER_LEVEL_A",(function(){return S})),n.d(t,"RENDER_LEVEL_S",(function(){return U})),n.d(t,"SIDE_BOTH",(function(){return I})),n.d(t,"SIDE_FRONT",(function(){return D})),n.d(t,"SIDE_BACK",(function(){return k})),n.d(t,"passRenderLevel",(function(){return P}));var i=0,a=2,o=3,u=1,f=1,s=0,l=2,c=3,d=4,v=0,m=1,_=2,E=3,p=4,h=5,y=6,R=7,C=8,T=0,g=1,x=2,O=3,V="none",L="B+",A="B",N="A+",S="A",U="S",I=1032,D=1028,k=1029,M=((r={})[U]=[U,L,N],r[S]=[S,L,N],r[A]=[A,L],r);function P(e,t){if(!e||!t)return!0;var n=M[t];return!!n&&n.indexOf(e)>-1}},function(e,t){e.exports="precision mediump float;\nvarying float vLife;\nvarying vec2 vTexCoord;\nvarying vec4 vColor;\nuniform sampler2D uMaskTex;\nuniform vec4 uColorParams;//mask opacityOverLifetime lum_texture\nuniform vec2 uTexOffset;\n\n#ifdef COLOR_OVER_LIFETIME\nuniform sampler2D uColorOverLifetime;\n#endif\n\n#ifdef USE_SPRITE\nvarying vec3 vTexCoordBlend;\nuniform vec4 uSprite;//col row totalFrame blend\n#endif\nvarying float vSeed;\n\n#ifdef PREVIEW_BORDER\nuniform vec4 uPreviewColor;\nvarying vec2 vPTexCoord;\nvarying vec2 vPTexSize;\n#endif\n\n\n\n#ifdef USE_SPRITE\nvec4 getTextureColor(sampler2D tex, vec2 texCoord){\n    if (uSprite.w > 0.){\n        return mix(texture2D(tex, texCoord), texture2D(tex, vTexCoordBlend.xy + texCoord), vTexCoordBlend.z);\n    }\n    return texture2D(tex, texCoord);\n}\n    #else\n    #define getTextureColor texture2D\n    #endif\n\n\n    #ifdef USE_FILTER\n    #pragma FILTER\n    #endif\n\nvoid main(){\n    vec4 color = vec4(1.0);\n    vec4 tempColor = vColor;\n    #ifdef USE_FILTER\n        #ifdef USE_SPRITE\n        #define TEXOFFSET uTexOffset / uSprite.xy\n        #else\n        #define TEXOFFSET uTexOffset\n        #endif\n    color = main_filter(Particle(vTexCoord, TEXOFFSET, vLife, vSeed),uMaskTex);\n    #else\n    if (uColorParams.x > 0.0){\n        color = getTextureColor(uMaskTex, vTexCoord);\n    }\n        #endif\n\n    if (uColorParams.z == 1.){\n        color = vec4(1., 1., 1., color.r * color.a);\n    }\n        #ifdef COLOR_OVER_LIFETIME\n        #ifndef ENABLE_VERTEX_TEXTURE\n        tempColor *= texture2D(uColorOverLifetime, vec2(vLife, 0.));\n        #endif\n        #endif\n    color = color * tempColor;\n\n\n    #ifdef PREVIEW_BORDER\n    float _tx = vPTexSize.x;\n    float _ty = vPTexSize.y;\n    if (vPTexCoord.x < _tx || vPTexCoord.x > (1. - _tx) || vPTexCoord.y < _ty || vPTexCoord.y > (1.-_ty)){\n        color.rgb = uPreviewColor.rgb * uPreviewColor.a;\n    }\n        #endif\n    gl_FragColor = color;\n}\n"},function(e,t){e.exports="precision mediump float;\n#define SHADER_VERTEX 1\n\n#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#endif\n\n#if CURVE_VALUE_COUNT\n#ifdef LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;\nconst float uCurveCount = 1./ float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#endif\n\n#ifdef SHADER_VERTEX\nattribute float aSeed;\nvarying float vSeed;\n#define NONE_CONST_INDEX 1\n#else\n    #ifdef LOOKUP_TEXTURE_CURVE\n    #define NONE_CONST_INDEX 1\n    #endif\n#endif\n\n#ifdef NONE_CONST_INDEX\n#define MAX_C  MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C  CURVE_VALUE_COUNT\n#endif\n\n#ifdef USE_CURVE_VALUE\nfloat evaluateCurveFrames(float time, vec4 keyframe0, vec4 keyframe1){\n    float dt = keyframe1.x - keyframe0.x;\n\n    float m0 = keyframe0.w * dt;\n    float m1 = keyframe1.z * dt;\n\n    float t = (time - keyframe0.x) / dt;\n    float t2 = t * t;\n    float t3 = t2 * t;\n\n    return dot(vec4(dot(vec3(2., -3., 1.), vec3(t3, t2, 1.)), dot(vec3(1, -2., 1), vec3(t3, t2, t)), t3 - t2, dot(vec2(-2, 3), vec2(t3, t2))), vec4(keyframe0.y, m0, m1, keyframe1.y));\n}\n\nfloat valueFromCurveFrames(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i == count){\n            return lookup_curve(count).y;\n        }\n        vec4 k0 = lookup_curve(i+start);\n        vec4 k1 = lookup_curve(i+1+start);\n        #else\n        if (i < start){\n            continue;\n        }\n        vec4 k0 = lookup_curve(i);\n        vec4 k1 = lookup_curve(i+1);\n        if (i == end){\n            return k0.y;\n        }\n            #endif\n        if (time >= k0.x && time <= k1.x){\n            return evaluateCurveFrames(time, k0, k1);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\n\n    #ifdef USE_LINE_SEG\n\nfloat evaluteLineSeg(float t, vec2 p0, vec2 p1){\n    return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);\n}\nfloat valueFromLineSegs(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i > count){\n            return lookup_curve(i).w;\n        }\n            #else\n        if (i<start){\n            continue;\n        }\n        if (i > end){\n            return lookup_curve(i-2).w;\n        }\n            #endif\n\n            #ifdef NONE_CONST_INDEX\n        vec4 seg = lookup_curve(i+start);\n        #else\n        vec4 seg = lookup_curve(i);\n        #endif\n        vec2 p0 = seg.xy;\n        vec2 p1 = seg.zw;\n        if (time >= p0.x && time <= p1.x){\n            return evaluteLineSeg(time, p0, p1);\n        }\n            #ifdef NONE_CONST_INDEX\n        vec2 p2 = lookup_curve(i+start+1).xy;\n        #else\n        vec2 p2 = lookup_curve(i+1).xy;\n        #endif\n        if (time > p1.x && time <= p2.x){\n            return evaluteLineSeg(time, p1, p2);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\nfloat getValueFromTime(float time, vec4 value){\n    float type = value.x;\n    if (type == 0.){\n        return value.y;\n    }\n    else if (type == 1.){\n        return mix(value.y, value.z, time / value.w);\n    }\n        #ifdef USE_LINE_SEG\n    if (type == 3.){\n        return valueFromLineSegs(time, value.y, value.z);\n    }\n        #endif\n        #ifdef USE_CURVE_VALUE\n    if (type == 2.){\n        return valueFromCurveFrames(time, value.y, value.z);\n    }\n        #endif\n    if (type == 4.){\n        #ifdef SHADER_VERTEX\n        float seed = aSeed;\n        #else\n        float seed = vSeed;\n        #endif\n        return mix(value.y, value.z, seed);\n    }\n    return 0.;\n}\n\n#ifdef USE_CURVE_VALUE\nfloat integrateCurveFrames(float t1, vec4 k0, vec4 k1) {\n    float k = k1.x - k0.x;\n    float m0 = k0.w * k;\n    float m1 = k1.z * k;\n    float t0 = k0.x;\n    float v0 = k0.y;\n    float v1 = k1.y;\n\n    float dt = t0 -t1;\n    float dt2 = dt * dt;\n    float dt3 = dt2 * dt;\n\n    vec4 a = vec4(dt3 * dt, dt3, dt2, dt) / vec4(4.*k*k*k, 3.*k*k, 2.*k, 1.);\n    vec4 b = vec4(m0+m1+2.*v0-2.*v1, 2.*m0+m1+3.*v0-3.*v1, m0, -v0);\n    return dot(a, b);\n}\n\nfloat integrateByTimeCurveFrames(float t1, vec4 k0, vec4 k1) {\n    float k = k1.x - k0.x;\n    float m0 = k0.w * k;\n    float m1 = k1.z * k;\n    float t0 = k0.x;\n    float v0 = k0.y;\n    float v1 = k1.y;\n\n    float dt = t0 - t1;\n    float dt2 = dt * dt;\n    float dt3 = dt2 * dt;\n    float k2 = k * k;\n    float k3 = k2 * k;\n\n    vec4 a = vec4(-30.*k3, 10.*k2, 5.*k, 3.) * vec4(dt, dt2, dt3, dt3*dt);\n    vec4 b = vec4(v0, m0, 2. * m0 + m1 + 3. * v0 - 3. * v1, m0 + m1 + 2. * v0 - 2. * v1)\n    * vec4(t0+t1, t0 + 2. * t1, t0 + 3. * t1, t0 + 4. * t1);\n    return dot(a, b) / 60. / k3;\n}\n\nfloat integrateByTimeFromCurveFrames(float t1, float frameStart, float frameCount){\n    if (t1 == 0.){\n        return 0.;\n    }\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    float ret = 0.;\n    for (int i = 0;i < MAX_KEY_FRAME_COUNT;i++){\n        if (i == count){\n            return ret;\n        }\n        vec4 k0 = lookup_curve(i+start);\n        vec4 k1 = lookup_curve(i+1+start);\n        if (t1 > k0.x && t1 <= k1.x){\n            return ret + integrateByTimeCurveFrames(t1, k0, k1);\n        }\n        ret += integrateByTimeCurveFrames(k1.x, k0, k1);\n    }\n    return ret;\n}\nfloat integrateFromCurveFrames(float time, float frameStart, float frameCount){\n    if (time == 0.){\n        return 0.;\n    }\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    float ret = 0.;\n    for (int i = 0;i < MAX_KEY_FRAME_COUNT;i++){\n        if (i == count){\n            return ret;\n        }\n        vec4 k0 = lookup_curve(i+start);\n        vec4 k1 = lookup_curve(i+1+start);\n        if (time > k0.x && time <= k1.x){\n            return ret + integrateCurveFrames(time, k0, k1);\n        }\n        ret += integrateCurveFrames(k1.x, k0, k1);\n\n    }\n    return ret;\n}\n    #endif\n\n\nfloat integrateByTimeLineSeg(float t, vec2 p0, vec2 p1){\n    float t0 = p0.x;\n    float t1 = p1.x;\n    float y0 = p0.y;\n    float y1 = p1.y;\n    float r = dot(vec4(2.*t*t*t, 3.*t*t, -t0*t0*t0, 3.*t0*t0), vec4(y0-y1, t0*y1-t1*y0, 2.*y0+y1, t1*y0));\n    return r/(t0-t1)/6.;\n}\nfloat integrateLineSeg(float time, vec2 p0, vec2 p1){\n    float h = time - p0.x;\n    float y0= p0.y;\n    return (y0 + y0 + (p1.y - y0) * h / (p1.x - p0.x)) * h / 2.;\n}\n\n    #ifdef USE_LINE_SEG\n\nfloat integrateFromLineSeg(float time, float frameStart, float frameCount){\n    if (time == 0.){\n        return 0.;\n    }\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    float ret = 0.;\n    for (int i = 0;i < MAX_KEY_FRAME_COUNT;i++){\n        if (i > count){\n            return ret;\n        }\n        vec4 ks = lookup_curve(i+start);\n        vec2 k0 = ks.xy;\n        vec2 k1 = ks.zw;\n        if (time > k0.x && time <= k1.x){\n            return ret + integrateLineSeg(time, k0, k1);\n        }\n        ret += integrateLineSeg(k1.x, k0, k1);\n        vec2 k2 = lookup_curve(i+start+1).xy;\n        if (time > k1.x && time <= k2.x){\n            return ret + integrateLineSeg(time, k1, k2);\n        }\n        ret += integrateLineSeg(k2.x, k1, k2);\n    }\n    return ret;\n}\nfloat integrateByTimeFromLineSeg(float time, float frameStart, float frameCount){\n    if (time == 0.){\n        return 0.;\n    }\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    float ret = 0.;\n    for (int i = 0;i < MAX_KEY_FRAME_COUNT;i++){\n        if (i > count){\n            return ret;\n        }\n        vec4 ks = lookup_curve(i+start);\n        vec2 k0 = ks.xy;\n        vec2 k1 = ks.zw;\n        if (time > k0.x && time <= k1.x){\n            return ret + integrateByTimeLineSeg(time, k0, k1);\n        }\n        ret += integrateByTimeLineSeg(k1.x, k0, k1);\n\n        vec2 k2 = lookup_curve(i+start+1).xy;\n        if (time > k1.x && time <= k2.x){\n            return ret + integrateByTimeLineSeg(time, k1, k2);\n        }\n        ret += integrateByTimeLineSeg(k2.x, k1, k2);\n    }\n    return ret;\n}\n\n    #endif\n\n/*\nfloat getIntegrateFromTime(float t0, float t1, vec4 value){\n  float type = value.x;\n  if (type == 0.){\n    return value.y * (t1 -t0);\n  } else if (type == 1.){\n    vec2 p0 = vec2(0., value.y);\n    vec2 p1 = vec2(value.w, value.z);\n    return integrateLineSeg(t1, p0, p1) - integrateLineSeg(t0, p0, p1);\n  } else if (type == 3.){\n    return integrateFromLineSeg(t1, value.y, value.z) - integrateFromLineSeg(t0, value.y, value.z);\n  } else if (type == 2.){\n    return integrateFromCurveFrames(t1, value.y, value.z) - integrateFromCurveFrames(t0, value.y, value.z);\n  } else if (type == 4.){\n    return mix(value.y, value.z, aSeed)* (t1 -t0);\n  }\n  return 0.;\n}\n*/\nfloat getIntegrateFromTime0(float t1, vec4 value){\n    float type = value.x;\n    if (type == 0.){\n        return value.y * t1;\n    } else if (type == 1.){\n        vec2 p0 = vec2(0., value.y);\n        vec2 p1 = vec2(value.w, value.z);\n        return integrateLineSeg(t1, p0, p1);\n    }\n        #ifdef USE_LINE_SEG\n    if (type == 3.){\n        return integrateFromLineSeg(t1, value.y, value.z);\n    }\n        #endif\n        #ifdef USE_CURVE_VALUE\n    if (type == 2.){\n        return integrateFromCurveFrames(t1, value.y, value.z);\n    }\n        #endif\n    if (type == 4.){\n        return mix(value.y, value.z, aSeed) * t1;\n    }\n    return 0.;\n}\n\nfloat getIntegrateByTimeFromTime(float t0, float t1, vec4 value){\n    float type = value.x;\n    if (type == 0.){\n        return value.y * (t1 * t1 - t0 * t0) / 2.;\n    } else if (type == 1.){\n        vec2 p0 = vec2(0., value.y);\n        vec2 p1 = vec2(value.w, value.z);\n        return integrateByTimeLineSeg(t1, p0, p1) - integrateByTimeLineSeg(t0, p0, p1);\n    }\n        #ifdef USE_LINE_SEG\n    if (type == 3.){\n        return integrateByTimeFromLineSeg(t1, value.y, value.z) - integrateByTimeFromLineSeg(t0, value.y, value.z);\n    }\n        #endif\n        #ifdef USE_CURVE_VALUE\n    if (type == 2.){\n        return integrateByTimeFromCurveFrames(t1, value.y, value.z) - integrateByTimeFromCurveFrames(t0, value.y, value.z);\n    }\n        #endif\n    if (type == 4.){\n        return mix(value.y, value.z, aSeed) * (t1 * t1 - t0 * t0) / 2.;\n    }\n    return 0.;\n}\n\n\nattribute vec3 aPos;\nattribute vec4 aOffset;//texcoord.xy size.xy\nattribute vec3 aVel;\nattribute vec3 aRot;\nattribute vec4 aColor;\nattribute vec2 aTime;//start duration\n\n#ifdef USE_SPRITE\nattribute vec3 aSprite;//start duration cycles\nuniform vec4 uSprite;//col row totalFrame blend\nvec2 getSpriteUV(vec2 uv, float lifeTime, out vec3 uv1);\nvarying vec3 vTexCoordBlend;\n#endif\n\nuniform mat4 uModel;\nuniform mat3 uCameraDir;\nuniform mat4 uViewProjection;\n\nuniform vec4 uParams;//time duration endBehavior\nuniform vec4 uAcceleration;\nuniform vec4 uColorParams;//mask opacityOverLifetime\nuniform vec4 uGravityModifierValue;\nuniform vec4 uOpacityOverLifetimeValue;\n#ifdef ROT_X_LIFETIME\nuniform vec4 uRXByLifeTimeValue;\n#endif\n\n#ifdef ROT_Y_LIFETIME\nuniform vec4 uRYByLifeTimeValue;\n#endif\n\n#ifdef ROT_Z_LIFETIME\nuniform vec4 uRZByLifeTimeValue;\n#endif\n\n#ifdef COLOR_OVER_LIFETIME\nuniform sampler2D uColorOverLifetime;\n#endif\n\n#if LINEAR_VEL_X + LINEAR_VEL_Y + LINEAR_VEL_Z\n#if LINEAR_VEL_X\nuniform vec4 uLinearXByLifetimeValue;\n#endif\n#if LINEAR_VEL_Y\nuniform vec4 uLinearYByLifetimeValue;\n#endif\n#if LINEAR_VEL_Z\nuniform vec4 uLinearZByLifetimeValue;\n#endif\n#endif\n\n#if ORB_VEL_X + ORB_VEL_Y + ORB_VEL_Z\n#if ORB_VEL_X\nuniform vec4 uOrbXByLifetimeValue;\n#endif\n#if ORB_VEL_Y\nuniform vec4 uOrbYByLifetimeValue;\n#endif\n#if ORB_VEL_Z\nuniform vec4 uOrbZByLifetimeValue;\n#endif\nuniform vec3 uOrbCenter;\n#endif\n\n#ifdef SIZE_BY_LIFE\nuniform vec4 uSizeByLifetimeValue;\n#endif\n#ifdef SIZE_Y_BY_LIFE\nuniform vec4 uSizeYByLifetimeValue;\n#endif\nvarying float vLife;\nvarying vec4 vColor;\nvarying vec2 vTexCoord;\n\n#ifdef PREVIEW_BORDER\nvarying vec2 vPTexCoord;\nvarying vec2 vPTexSize;\n#endif\n\nvec3 calOrbitalMov(float life){\n    vec3 orb = vec3(0.0);\n    #ifdef AS_ORBITAL_MOVEMENT\n    #define FUNC getValueFromTime\n    #else\n    #define FUNC getIntegrateFromTime0\n    #endif\n\n    #if ORB_VEL_X\n    orb.x = FUNC(life, uOrbXByLifetimeValue);\n    #endif\n\n    #if ORB_VEL_Y\n    orb.y = FUNC(life, uOrbYByLifetimeValue);\n    #endif\n\n    #if ORB_VEL_Z\n    orb.z = FUNC(life, uOrbZByLifetimeValue);\n    #endif\n    #undef FUNC\n    return orb;\n}\n\nvec3 calLinearMov(float life){\n    vec3 mov = vec3(0.0);\n    #ifdef AS_LINEAR_MOVEMENT\n    #define FUNC getValueFromTime\n    #else\n    #define FUNC getIntegrateFromTime0\n    #endif\n\n    #if LINEAR_VEL_X\n    mov.x = FUNC(life, uLinearXByLifetimeValue);\n    #endif\n\n    #if LINEAR_VEL_Y\n    mov.y = FUNC(life, uLinearYByLifetimeValue);\n    #endif\n\n    #if LINEAR_VEL_Z\n    mov.z = FUNC(life, uLinearZByLifetimeValue);\n    #endif\n    #undef FUNC\n    return mov;\n}\n\nmat3 mat3FromRotation(vec3 rotation){\n    vec3 sinR = sin(rotation);\n    vec3 cosR = cos(rotation);\n\n\n    //            return mat3(\n    //            cosR.y * cosR.z, -cosR.x * sinR.z + sinR.x * sinR.y * cosR.z, sinR.z * sinR.x + cosR.x * sinR.y * cosR.z,\n    //            cosR.y * sinR.z, cosR.x * cosR.z + sinR.x * sinR.y * sinR.z, -sinR.x*cosR.z + cosR.x * sinR.y * sinR.z,\n    //            -sinR.y, sinR.x * cosR.y, cosR.x * cosR.y\n    //            );\n\n    return mat3(cosR.z, -sinR.z, 0., sinR.z, cosR.z, 0., 0., 0., 1.)\n    * mat3(cosR.y, 0., sinR.y, 0., 1., 0., -sinR.y, 0, cosR.y)\n    * mat3(1., 0., 0., 0, cosR.x, -sinR.x, 0., sinR.x, cosR.x);\n}\n\n\n    #ifdef USE_SPRITE\n\nvec2 getSpriteUV(vec2 uv, float lifeTime, out vec3 uv1){\n    float t = clamp((lifeTime - aSprite.x)/aSprite.y, 0.0, 1.) * aSprite.z;\n    float frame = uSprite.z * t;\n    float frameIndex = max(ceil(frame) - 1.,0.);\n    float row = floor((frameIndex+0.1)/uSprite.x);\n    float col = frameIndex - row * uSprite.x;\n\n    vec2 retUV =(vec2(col, row)+uv) / uSprite.xy;\n\n    if(uSprite.w >0.){\n        float blend = frame - frameIndex;\n        float frameIndex1 = min(ceil(frame), uSprite.z - 1.);\n        float row1 = floor((frameIndex1+0.1)/uSprite.x);\n        float col1 = frameIndex1 - row1 * uSprite.x;\n        uv1 = vec3((vec2(col1, row1)+uv) / uSprite.xy - retUV, blend);\n    }\n    return retUV;\n}\n    #endif\n\nvec3 calculateTranslation(vec3 vel, float t0, float t1){\n    float dt = t1 - t0;\n    float d = getIntegrateByTimeFromTime(0., dt, uGravityModifierValue);\n    vec3 acc = uAcceleration.xyz * d;\n    return vel * dt + acc;\n}\n\nmat3 transformFromRotation(vec3 rot, float time){\n    vec3 rotation = rot;\n    #ifdef ROT_LIFETIME_AS_MOVEMENT\n    #define FUNC1 getValueFromTime\n    #else\n    #define FUNC1 getIntegrateFromTime0\n    #endif\n\n    #ifdef ROT_X_LIFETIME\n    rotation.x += FUNC1(time, uRXByLifeTimeValue);\n    #endif\n\n    #ifdef ROT_Y_LIFETIME\n    rotation.y += FUNC1(time, uRYByLifeTimeValue);\n    #endif\n\n    #ifdef ROT_Z_LIFETIME\n    rotation.z += FUNC1(time, uRZByLifeTimeValue);\n    #endif\n\n    if (dot(rotation, rotation) == 0.0){\n        return mat3(1.0);\n    }\n        #undef FUNC1\n    return mat3FromRotation(rotation);\n}\n\n\n\nvoid main(){\n    float time = uParams.x - aTime.x;\n    if (time < 0. || time - aTime.y > uParams.z){\n        gl_Position = vec4(-3., -3., -3., 1.);\n    }\n    else {\n        float life = clamp(time/aTime.y, 0.0, 1.0);\n        vLife = life;\n\n        #ifdef USE_SPRITE\n        vec3 tBlend;\n        vTexCoord = getSpriteUV(aOffset.xy, life, tBlend);\n        vTexCoordBlend = tBlend;\n        #else\n        vTexCoord = aOffset.xy;\n        #endif\n\n\n        vColor = aColor;\n\n        #ifdef COLOR_OVER_LIFETIME\n        #ifdef ENABLE_VERTEX_TEXTURE\n        vColor *= texture2D(uColorOverLifetime, vec2(life, 0.));\n        #endif\n        #endif\n\n        if (uColorParams.y >0.0){\n            vColor.a *= clamp(getValueFromTime(life, uOpacityOverLifetimeValue), 0., 1.);\n        }\n\n\n        vec2 size = vec2(1.0);\n        #ifdef SIZE_BY_LIFE\n        size = vec2(getValueFromTime(life, uSizeByLifetimeValue));\n        #endif\n\n        #ifdef SIZE_Y_BY_LIFE\n        size.y = getValueFromTime(life, uSizeYByLifetimeValue);\n        #endif\n\n        #ifdef PREVIEW_BORDER\n        vPTexCoord = aOffset.xy;\n        vPTexSize = size * 0.03;\n        #endif\n\n        vec3 point = transformFromRotation(aRot, life) * vec3(aOffset.zw * size, 0.);\n        vec3 pt = calculateTranslation(aVel, aTime.x, uParams.x);\n        vec4 pos = uModel * vec4(aPos + pt, 1.0);\n\n        #if ORB_VEL_X + ORB_VEL_Y + ORB_VEL_Z\n        pos.xyz = (pos.xyz - uOrbCenter) * mat3FromRotation(calOrbitalMov(life));\n        #endif\n\n        #if LINEAR_VEL_X + LINEAR_VEL_Y + LINEAR_VEL_Z\n        pos.xyz += calLinearMov(life);\n        #endif\n\n        #if RENDER_MODE == 1\n        vec4 p =uModel * vec4(point, 1.0);\n        pos.xyz += p.xyz/p.w;\n        #elif RENDER_MODE == 3\n        pos.xyz += uCameraDir[0] * point.x + uCameraDir[2] * point.y;\n        #elif RENDER_MODE == 2\n        pos.xy += point.xy;\n        #elif RENDER_MODE == 0\n        pos.xyz += uCameraDir[0] * point.x + uCameraDir[1] * point.y;\n        #endif\n        gl_Position = uViewProjection * pos;\n        vSeed = aSeed;\n    }\n}\n"},function(e,t){e.exports="#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#endif\n\n#if CURVE_VALUE_COUNT\n#ifdef LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;\nconst float uCurveCount = 1./ float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#endif\n\n#ifdef SHADER_VERTEX\nattribute float aSeed;\nvarying float vSeed;\n#define NONE_CONST_INDEX 1\n#else\n    #ifdef LOOKUP_TEXTURE_CURVE\n    #define NONE_CONST_INDEX 1\n    #endif\n#endif\n\n#ifdef NONE_CONST_INDEX\n#define MAX_C  MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C  CURVE_VALUE_COUNT\n#endif\n\n#ifdef USE_CURVE_VALUE\nfloat evaluateCurveFrames(float time, vec4 keyframe0, vec4 keyframe1){\n    float dt = keyframe1.x - keyframe0.x;\n\n    float m0 = keyframe0.w * dt;\n    float m1 = keyframe1.z * dt;\n\n    float t = (time - keyframe0.x) / dt;\n    float t2 = t * t;\n    float t3 = t2 * t;\n\n    return dot(vec4(dot(vec3(2., -3., 1.), vec3(t3, t2, 1.)), dot(vec3(1, -2., 1), vec3(t3, t2, t)), t3 - t2, dot(vec2(-2, 3), vec2(t3, t2))), vec4(keyframe0.y, m0, m1, keyframe1.y));\n}\n\nfloat valueFromCurveFrames(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i == count){\n            return lookup_curve(count).y;\n        }\n        vec4 k0 = lookup_curve(i+start);\n        vec4 k1 = lookup_curve(i+1+start);\n        #else\n        if (i < start){\n            continue;\n        }\n        vec4 k0 = lookup_curve(i);\n        vec4 k1 = lookup_curve(i+1);\n        if (i == end){\n            return k0.y;\n        }\n            #endif\n        if (time >= k0.x && time <= k1.x){\n            return evaluateCurveFrames(time, k0, k1);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\n\n    #ifdef USE_LINE_SEG\n\nfloat evaluteLineSeg(float t, vec2 p0, vec2 p1){\n    return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);\n}\nfloat valueFromLineSegs(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i > count){\n            return lookup_curve(i).w;\n        }\n            #else\n        if (i<start){\n            continue;\n        }\n        if (i > end){\n            return lookup_curve(i-2).w;\n        }\n            #endif\n\n            #ifdef NONE_CONST_INDEX\n        vec4 seg = lookup_curve(i+start);\n        #else\n        vec4 seg = lookup_curve(i);\n        #endif\n        vec2 p0 = seg.xy;\n        vec2 p1 = seg.zw;\n        if (time >= p0.x && time <= p1.x){\n            return evaluteLineSeg(time, p0, p1);\n        }\n            #ifdef NONE_CONST_INDEX\n        vec2 p2 = lookup_curve(i+start+1).xy;\n        #else\n        vec2 p2 = lookup_curve(i+1).xy;\n        #endif\n        if (time > p1.x && time <= p2.x){\n            return evaluteLineSeg(time, p1, p2);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\nfloat getValueFromTime(float time, vec4 value){\n    float type = value.x;\n    if (type == 0.){\n        return value.y;\n    }\n    else if (type == 1.){\n        return mix(value.y, value.z, time / value.w);\n    }\n        #ifdef USE_LINE_SEG\n    if (type == 3.){\n        return valueFromLineSegs(time, value.y, value.z);\n    }\n        #endif\n        #ifdef USE_CURVE_VALUE\n    if (type == 2.){\n        return valueFromCurveFrames(time, value.y, value.z);\n    }\n        #endif\n    if (type == 4.){\n        #ifdef SHADER_VERTEX\n        float seed = aSeed;\n        #else\n        float seed = vSeed;\n        #endif\n        return mix(value.y, value.z, seed);\n    }\n    return 0.;\n}\n\n#ifdef USE_FILTER\n\nstruct Particle{\n  vec2 texCoord;\n  vec2 texOffset;\n  float lifetime;\n  float seed;\n};\n\n#endif\n\n\nuniform sampler2D uNoise;\nuniform sampler2D uBlend;\nuniform vec4 uStrengthValue;\nuniform vec2 uClipPoint;\n\nvec4 main_filter(Particle p,sampler2D texture) {\n    float dis = 1.0 - length(p.texCoord - uClipPoint)/sqrt(0.5);\n    vec2 noiseCoord = fract(p.texCoord + vec2(p.seed));\n    float noise = texture2D(uNoise, noiseCoord).r;\n    float strength = getValueFromTime(p.lifetime, uStrengthValue);\n    float d = (dis + noise) /2. + strength;\n    if (d > 1.){\n        return getTextureColor(uBlend, p.texCoord);\n    }\n    return getTextureColor(texture,p.texCoord);\n}\n"},function(e,t){e.exports="#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#endif\n\n#if CURVE_VALUE_COUNT\n#ifdef LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;\nconst float uCurveCount = 1./ float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#endif\n\n#ifdef SHADER_VERTEX\nattribute float aSeed;\nvarying float vSeed;\n#define NONE_CONST_INDEX 1\n#else\n    #ifdef LOOKUP_TEXTURE_CURVE\n    #define NONE_CONST_INDEX 1\n    #endif\n#endif\n\n#ifdef NONE_CONST_INDEX\n#define MAX_C  MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C  CURVE_VALUE_COUNT\n#endif\n\n#ifdef USE_CURVE_VALUE\nfloat evaluateCurveFrames(float time, vec4 keyframe0, vec4 keyframe1){\n    float dt = keyframe1.x - keyframe0.x;\n\n    float m0 = keyframe0.w * dt;\n    float m1 = keyframe1.z * dt;\n\n    float t = (time - keyframe0.x) / dt;\n    float t2 = t * t;\n    float t3 = t2 * t;\n\n    return dot(vec4(dot(vec3(2., -3., 1.), vec3(t3, t2, 1.)), dot(vec3(1, -2., 1), vec3(t3, t2, t)), t3 - t2, dot(vec2(-2, 3), vec2(t3, t2))), vec4(keyframe0.y, m0, m1, keyframe1.y));\n}\n\nfloat valueFromCurveFrames(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i == count){\n            return lookup_curve(count).y;\n        }\n        vec4 k0 = lookup_curve(i+start);\n        vec4 k1 = lookup_curve(i+1+start);\n        #else\n        if (i < start){\n            continue;\n        }\n        vec4 k0 = lookup_curve(i);\n        vec4 k1 = lookup_curve(i+1);\n        if (i == end){\n            return k0.y;\n        }\n            #endif\n        if (time >= k0.x && time <= k1.x){\n            return evaluateCurveFrames(time, k0, k1);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\n\n    #ifdef USE_LINE_SEG\n\nfloat evaluteLineSeg(float t, vec2 p0, vec2 p1){\n    return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);\n}\nfloat valueFromLineSegs(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i > count){\n            return lookup_curve(i).w;\n        }\n            #else\n        if (i<start){\n            continue;\n        }\n        if (i > end){\n            return lookup_curve(i-2).w;\n        }\n            #endif\n\n            #ifdef NONE_CONST_INDEX\n        vec4 seg = lookup_curve(i+start);\n        #else\n        vec4 seg = lookup_curve(i);\n        #endif\n        vec2 p0 = seg.xy;\n        vec2 p1 = seg.zw;\n        if (time >= p0.x && time <= p1.x){\n            return evaluteLineSeg(time, p0, p1);\n        }\n            #ifdef NONE_CONST_INDEX\n        vec2 p2 = lookup_curve(i+start+1).xy;\n        #else\n        vec2 p2 = lookup_curve(i+1).xy;\n        #endif\n        if (time > p1.x && time <= p2.x){\n            return evaluteLineSeg(time, p1, p2);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\nfloat getValueFromTime(float time, vec4 value){\n    float type = value.x;\n    if (type == 0.){\n        return value.y;\n    }\n    else if (type == 1.){\n        return mix(value.y, value.z, time / value.w);\n    }\n        #ifdef USE_LINE_SEG\n    if (type == 3.){\n        return valueFromLineSegs(time, value.y, value.z);\n    }\n        #endif\n        #ifdef USE_CURVE_VALUE\n    if (type == 2.){\n        return valueFromCurveFrames(time, value.y, value.z);\n    }\n        #endif\n    if (type == 4.){\n        #ifdef SHADER_VERTEX\n        float seed = aSeed;\n        #else\n        float seed = vSeed;\n        #endif\n        return mix(value.y, value.z, seed);\n    }\n    return 0.;\n}\n\n#ifdef USE_FILTER\n\nstruct Particle{\n  vec2 texCoord;\n  vec2 texOffset;\n  float lifetime;\n  float seed;\n};\n\n#endif\n\n\nuniform vec4 uOpacityOverXValue;\nuniform vec4 uOpacityOverYValue;\nuniform vec4 uDisplayMinXValue;\nuniform vec4 uDisplayMinYValue;\nuniform vec4 uDisplayMaxXValue;\nuniform vec4 uDisplayMaxYValue;\n\nuniform vec2 uFlipDir;\n\nvec4 main_filter(Particle p,sampler2D texture) {\n    vec2 texCoord = p.texCoord;\n    float l = p.lifetime;\n    if(texCoord.x < getValueFromTime(l,uDisplayMinXValue)\n    || texCoord.x > getValueFromTime(l,uDisplayMaxXValue)\n    || texCoord.y < getValueFromTime(l,uDisplayMinYValue)\n    || texCoord.y > getValueFromTime(l,uDisplayMaxYValue)\n    ){\n        return vec4(0.);\n    }\n    float opacity = getValueFromTime(texCoord.x, uOpacityOverXValue) * getValueFromTime(texCoord.y, uOpacityOverYValue);\n    vec2 point = (texCoord - 0.5) * uFlipDir + 0.5;\n    return getTextureColor(texture,point) * opacity;\n}\n"},function(e,t){e.exports="#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#endif\n\n#if CURVE_VALUE_COUNT\n#ifdef LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;\nconst float uCurveCount = 1./ float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#endif\n\n#ifdef SHADER_VERTEX\nattribute float aSeed;\nvarying float vSeed;\n#define NONE_CONST_INDEX 1\n#else\n    #ifdef LOOKUP_TEXTURE_CURVE\n    #define NONE_CONST_INDEX 1\n    #endif\n#endif\n\n#ifdef NONE_CONST_INDEX\n#define MAX_C  MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C  CURVE_VALUE_COUNT\n#endif\n\n#ifdef USE_CURVE_VALUE\nfloat evaluateCurveFrames(float time, vec4 keyframe0, vec4 keyframe1){\n    float dt = keyframe1.x - keyframe0.x;\n\n    float m0 = keyframe0.w * dt;\n    float m1 = keyframe1.z * dt;\n\n    float t = (time - keyframe0.x) / dt;\n    float t2 = t * t;\n    float t3 = t2 * t;\n\n    return dot(vec4(dot(vec3(2., -3., 1.), vec3(t3, t2, 1.)), dot(vec3(1, -2., 1), vec3(t3, t2, t)), t3 - t2, dot(vec2(-2, 3), vec2(t3, t2))), vec4(keyframe0.y, m0, m1, keyframe1.y));\n}\n\nfloat valueFromCurveFrames(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i == count){\n            return lookup_curve(count).y;\n        }\n        vec4 k0 = lookup_curve(i+start);\n        vec4 k1 = lookup_curve(i+1+start);\n        #else\n        if (i < start){\n            continue;\n        }\n        vec4 k0 = lookup_curve(i);\n        vec4 k1 = lookup_curve(i+1);\n        if (i == end){\n            return k0.y;\n        }\n            #endif\n        if (time >= k0.x && time <= k1.x){\n            return evaluateCurveFrames(time, k0, k1);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\n\n    #ifdef USE_LINE_SEG\n\nfloat evaluteLineSeg(float t, vec2 p0, vec2 p1){\n    return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);\n}\nfloat valueFromLineSegs(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i > count){\n            return lookup_curve(i).w;\n        }\n            #else\n        if (i<start){\n            continue;\n        }\n        if (i > end){\n            return lookup_curve(i-2).w;\n        }\n            #endif\n\n            #ifdef NONE_CONST_INDEX\n        vec4 seg = lookup_curve(i+start);\n        #else\n        vec4 seg = lookup_curve(i);\n        #endif\n        vec2 p0 = seg.xy;\n        vec2 p1 = seg.zw;\n        if (time >= p0.x && time <= p1.x){\n            return evaluteLineSeg(time, p0, p1);\n        }\n            #ifdef NONE_CONST_INDEX\n        vec2 p2 = lookup_curve(i+start+1).xy;\n        #else\n        vec2 p2 = lookup_curve(i+1).xy;\n        #endif\n        if (time > p1.x && time <= p2.x){\n            return evaluteLineSeg(time, p1, p2);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\nfloat getValueFromTime(float time, vec4 value){\n    float type = value.x;\n    if (type == 0.){\n        return value.y;\n    }\n    else if (type == 1.){\n        return mix(value.y, value.z, time / value.w);\n    }\n        #ifdef USE_LINE_SEG\n    if (type == 3.){\n        return valueFromLineSegs(time, value.y, value.z);\n    }\n        #endif\n        #ifdef USE_CURVE_VALUE\n    if (type == 2.){\n        return valueFromCurveFrames(time, value.y, value.z);\n    }\n        #endif\n    if (type == 4.){\n        #ifdef SHADER_VERTEX\n        float seed = aSeed;\n        #else\n        float seed = vSeed;\n        #endif\n        return mix(value.y, value.z, seed);\n    }\n    return 0.;\n}\n\n#ifdef USE_FILTER\n\nstruct Particle{\n  vec2 texCoord;\n  vec2 texOffset;\n  float lifetime;\n  float seed;\n};\n\n#endif\n\n\nuniform vec2 uCenter;\nuniform vec4 uRadiusValue;\nuniform vec4 uAngleValue;\nuniform vec4 uBlendOpacityValue;\nuniform vec4 uStrengthValue;\nuniform sampler2D uBlend;\n\nvec4 main_filter(Particle p,sampler2D texture) {\n    vec2 texCoord = p.texCoord;\n    float radius = getValueFromTime(p.lifetime,uRadiusValue);\n    float dis = distance(texCoord,uCenter);\n    const float d2r = 3.14159 / 180.;\n    if(radius > dis){\n        float angle = getValueFromTime(p.lifetime,uAngleValue)* d2r;\n        float percent = (radius - dis) / radius;\n        float theta = percent * percent * angle * getValueFromTime(p.lifetime,uStrengthValue);\n        float s = sin(theta);\n        float c = cos(theta);\n        texCoord -= uCenter;\n        texCoord = vec2(dot(texCoord, vec2(c, -s)), dot(texCoord, vec2(s, c)));\n        texCoord += uCenter;\n    }\n    vec4 originColor = getTextureColor(texture,texCoord);\n    float blendOpacity = getValueFromTime(p.lifetime,uBlendOpacityValue);\n    if(blendOpacity > 0.){\n        return mix(originColor,getTextureColor(uBlend,texCoord),blendOpacity);\n    }\n    return originColor;\n}\n"},function(e,t){e.exports="#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#endif\n\n#if CURVE_VALUE_COUNT\n#ifdef LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;\nconst float uCurveCount = 1./ float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#endif\n\n#ifdef SHADER_VERTEX\nattribute float aSeed;\nvarying float vSeed;\n#define NONE_CONST_INDEX 1\n#else\n    #ifdef LOOKUP_TEXTURE_CURVE\n    #define NONE_CONST_INDEX 1\n    #endif\n#endif\n\n#ifdef NONE_CONST_INDEX\n#define MAX_C  MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C  CURVE_VALUE_COUNT\n#endif\n\n#ifdef USE_CURVE_VALUE\nfloat evaluateCurveFrames(float time, vec4 keyframe0, vec4 keyframe1){\n    float dt = keyframe1.x - keyframe0.x;\n\n    float m0 = keyframe0.w * dt;\n    float m1 = keyframe1.z * dt;\n\n    float t = (time - keyframe0.x) / dt;\n    float t2 = t * t;\n    float t3 = t2 * t;\n\n    return dot(vec4(dot(vec3(2., -3., 1.), vec3(t3, t2, 1.)), dot(vec3(1, -2., 1), vec3(t3, t2, t)), t3 - t2, dot(vec2(-2, 3), vec2(t3, t2))), vec4(keyframe0.y, m0, m1, keyframe1.y));\n}\n\nfloat valueFromCurveFrames(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i == count){\n            return lookup_curve(count).y;\n        }\n        vec4 k0 = lookup_curve(i+start);\n        vec4 k1 = lookup_curve(i+1+start);\n        #else\n        if (i < start){\n            continue;\n        }\n        vec4 k0 = lookup_curve(i);\n        vec4 k1 = lookup_curve(i+1);\n        if (i == end){\n            return k0.y;\n        }\n            #endif\n        if (time >= k0.x && time <= k1.x){\n            return evaluateCurveFrames(time, k0, k1);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\n\n    #ifdef USE_LINE_SEG\n\nfloat evaluteLineSeg(float t, vec2 p0, vec2 p1){\n    return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);\n}\nfloat valueFromLineSegs(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i > count){\n            return lookup_curve(i).w;\n        }\n            #else\n        if (i<start){\n            continue;\n        }\n        if (i > end){\n            return lookup_curve(i-2).w;\n        }\n            #endif\n\n            #ifdef NONE_CONST_INDEX\n        vec4 seg = lookup_curve(i+start);\n        #else\n        vec4 seg = lookup_curve(i);\n        #endif\n        vec2 p0 = seg.xy;\n        vec2 p1 = seg.zw;\n        if (time >= p0.x && time <= p1.x){\n            return evaluteLineSeg(time, p0, p1);\n        }\n            #ifdef NONE_CONST_INDEX\n        vec2 p2 = lookup_curve(i+start+1).xy;\n        #else\n        vec2 p2 = lookup_curve(i+1).xy;\n        #endif\n        if (time > p1.x && time <= p2.x){\n            return evaluteLineSeg(time, p1, p2);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\nfloat getValueFromTime(float time, vec4 value){\n    float type = value.x;\n    if (type == 0.){\n        return value.y;\n    }\n    else if (type == 1.){\n        return mix(value.y, value.z, time / value.w);\n    }\n        #ifdef USE_LINE_SEG\n    if (type == 3.){\n        return valueFromLineSegs(time, value.y, value.z);\n    }\n        #endif\n        #ifdef USE_CURVE_VALUE\n    if (type == 2.){\n        return valueFromCurveFrames(time, value.y, value.z);\n    }\n        #endif\n    if (type == 4.){\n        #ifdef SHADER_VERTEX\n        float seed = aSeed;\n        #else\n        float seed = vSeed;\n        #endif\n        return mix(value.y, value.z, seed);\n    }\n    return 0.;\n}\n\n#ifdef USE_FILTER\n\nstruct Particle{\n  vec2 texCoord;\n  vec2 texOffset;\n  float lifetime;\n  float seed;\n};\n\n#endif\n\n\n\nuniform vec4 uWaveParams;//center frequency blendMethod\nuniform vec4 uWaveMovementValue;\nuniform vec4 uWaveHeightValue;\nuniform vec4 uWaveDampingValue;\nuniform vec4 uBlendOpacityValue;\nuniform sampler2D uBlend;\n\nvec3 getPointHeight(vec2 texcoord, float xc, float waveDamping, float waveHeight){\n    float dist = distance(texcoord, uWaveParams.xy);\n    float d = (xc - dist) * waveDamping;\n    return vec3(texcoord, cos(d * uWaveParams.z) * max(1. - d * d, 0.) * waveHeight);\n}\n\nvec4 main_filter(Particle p,sampler2D texture){\n    const vec3 light = vec3(0., 0., -1.);\n    float life = p.lifetime;\n    vec2 tc = p.texCoord;\n    float blendMethod = uWaveParams.w;\n    float waveMovement = getValueFromTime(life, uWaveMovementValue);\n    float waveDamping = getValueFromTime(life, uWaveDampingValue);\n    float opacity = clamp(getValueFromTime(life, uBlendOpacityValue), 0., 1.);\n    float d = (waveMovement - distance(tc, uWaveParams.xy)) * waveDamping;\n    vec4 color;\n    float waveHeight = getValueFromTime(life, uWaveHeightValue);\n    vec3 p0 = getPointHeight(tc, waveMovement, waveDamping, waveHeight);\n    vec3 p1 = getPointHeight(tc+ vec2(p.texOffset.x * uWaveParams.z, 0.), waveMovement, waveDamping, waveHeight);\n    vec3 p2 = getPointHeight(tc+ vec2(0., p.texOffset.y * uWaveParams.z), waveMovement, waveDamping, waveHeight);\n    vec3 r = refract(light, normalize(cross(p0-p1, p0-p2)), 0.8);\n    float k = r.z == 0. ? 0.:- p0.z /r.z;\n    color = getTextureColor(texture,tc + k * r.xy);\n    if (blendMethod == 0.){\n        return color;\n    }\n    vec4 blendColor = getTextureColor(uBlend, tc);\n    if (blendMethod == 2.){\n        float dist = distance(tc, uWaveParams.xy);\n        float d = clamp((waveMovement - dist) * waveDamping + 1., 0., 1.);\n        opacity = d * opacity;\n    }\n    return mix(color, blendColor, opacity);\n}\n\n\n"},function(e,t){e.exports="#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#endif\n\n#if CURVE_VALUE_COUNT\n#ifdef LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;\nconst float uCurveCount = 1./ float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#endif\n\n#ifdef SHADER_VERTEX\nattribute float aSeed;\nvarying float vSeed;\n#define NONE_CONST_INDEX 1\n#else\n    #ifdef LOOKUP_TEXTURE_CURVE\n    #define NONE_CONST_INDEX 1\n    #endif\n#endif\n\n#ifdef NONE_CONST_INDEX\n#define MAX_C  MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C  CURVE_VALUE_COUNT\n#endif\n\n#ifdef USE_CURVE_VALUE\nfloat evaluateCurveFrames(float time, vec4 keyframe0, vec4 keyframe1){\n    float dt = keyframe1.x - keyframe0.x;\n\n    float m0 = keyframe0.w * dt;\n    float m1 = keyframe1.z * dt;\n\n    float t = (time - keyframe0.x) / dt;\n    float t2 = t * t;\n    float t3 = t2 * t;\n\n    return dot(vec4(dot(vec3(2., -3., 1.), vec3(t3, t2, 1.)), dot(vec3(1, -2., 1), vec3(t3, t2, t)), t3 - t2, dot(vec2(-2, 3), vec2(t3, t2))), vec4(keyframe0.y, m0, m1, keyframe1.y));\n}\n\nfloat valueFromCurveFrames(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i == count){\n            return lookup_curve(count).y;\n        }\n        vec4 k0 = lookup_curve(i+start);\n        vec4 k1 = lookup_curve(i+1+start);\n        #else\n        if (i < start){\n            continue;\n        }\n        vec4 k0 = lookup_curve(i);\n        vec4 k1 = lookup_curve(i+1);\n        if (i == end){\n            return k0.y;\n        }\n            #endif\n        if (time >= k0.x && time <= k1.x){\n            return evaluateCurveFrames(time, k0, k1);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\n\n    #ifdef USE_LINE_SEG\n\nfloat evaluteLineSeg(float t, vec2 p0, vec2 p1){\n    return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);\n}\nfloat valueFromLineSegs(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i > count){\n            return lookup_curve(i).w;\n        }\n            #else\n        if (i<start){\n            continue;\n        }\n        if (i > end){\n            return lookup_curve(i-2).w;\n        }\n            #endif\n\n            #ifdef NONE_CONST_INDEX\n        vec4 seg = lookup_curve(i+start);\n        #else\n        vec4 seg = lookup_curve(i);\n        #endif\n        vec2 p0 = seg.xy;\n        vec2 p1 = seg.zw;\n        if (time >= p0.x && time <= p1.x){\n            return evaluteLineSeg(time, p0, p1);\n        }\n            #ifdef NONE_CONST_INDEX\n        vec2 p2 = lookup_curve(i+start+1).xy;\n        #else\n        vec2 p2 = lookup_curve(i+1).xy;\n        #endif\n        if (time > p1.x && time <= p2.x){\n            return evaluteLineSeg(time, p1, p2);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\nfloat getValueFromTime(float time, vec4 value){\n    float type = value.x;\n    if (type == 0.){\n        return value.y;\n    }\n    else if (type == 1.){\n        return mix(value.y, value.z, time / value.w);\n    }\n        #ifdef USE_LINE_SEG\n    if (type == 3.){\n        return valueFromLineSegs(time, value.y, value.z);\n    }\n        #endif\n        #ifdef USE_CURVE_VALUE\n    if (type == 2.){\n        return valueFromCurveFrames(time, value.y, value.z);\n    }\n        #endif\n    if (type == 4.){\n        #ifdef SHADER_VERTEX\n        float seed = aSeed;\n        #else\n        float seed = vSeed;\n        #endif\n        return mix(value.y, value.z, seed);\n    }\n    return 0.;\n}\n\n#ifdef USE_FILTER\n\nstruct Particle{\n  vec2 texCoord;\n  vec2 texOffset;\n  float lifetime;\n  float seed;\n};\n\n#endif\n\n\nuniform sampler2D uBlend;\nuniform vec4 uTextureOffsetX;\nuniform vec4 uTextureOffsetY;\n\nvec4 main_filter(Particle p,sampler2D texture) {\n    float mask = getTextureColor(texture, p.texCoord).r;\n    if (mask < 0.9){\n        discard;\n    }\n    float life = p.lifetime;\n    vec2 uv = vec2(getValueFromTime(life, uTextureOffsetX), getValueFromTime(life, uTextureOffsetY));\n    return getTextureColor(uBlend, p.texCoord - uv) * mask;\n}\n"},function(e,t){e.exports="precision mediump float;\n#define SHADER_VERTEX 1\n\n#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#endif\n\n#if CURVE_VALUE_COUNT\n#ifdef LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;\nconst float uCurveCount = 1./ float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#endif\n\n#ifdef SHADER_VERTEX\nattribute float aSeed;\nvarying float vSeed;\n#define NONE_CONST_INDEX 1\n#else\n    #ifdef LOOKUP_TEXTURE_CURVE\n    #define NONE_CONST_INDEX 1\n    #endif\n#endif\n\n#ifdef NONE_CONST_INDEX\n#define MAX_C  MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C  CURVE_VALUE_COUNT\n#endif\n\n#ifdef USE_CURVE_VALUE\nfloat evaluateCurveFrames(float time, vec4 keyframe0, vec4 keyframe1){\n    float dt = keyframe1.x - keyframe0.x;\n\n    float m0 = keyframe0.w * dt;\n    float m1 = keyframe1.z * dt;\n\n    float t = (time - keyframe0.x) / dt;\n    float t2 = t * t;\n    float t3 = t2 * t;\n\n    return dot(vec4(dot(vec3(2., -3., 1.), vec3(t3, t2, 1.)), dot(vec3(1, -2., 1), vec3(t3, t2, t)), t3 - t2, dot(vec2(-2, 3), vec2(t3, t2))), vec4(keyframe0.y, m0, m1, keyframe1.y));\n}\n\nfloat valueFromCurveFrames(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i == count){\n            return lookup_curve(count).y;\n        }\n        vec4 k0 = lookup_curve(i+start);\n        vec4 k1 = lookup_curve(i+1+start);\n        #else\n        if (i < start){\n            continue;\n        }\n        vec4 k0 = lookup_curve(i);\n        vec4 k1 = lookup_curve(i+1);\n        if (i == end){\n            return k0.y;\n        }\n            #endif\n        if (time >= k0.x && time <= k1.x){\n            return evaluateCurveFrames(time, k0, k1);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\n\n    #ifdef USE_LINE_SEG\n\nfloat evaluteLineSeg(float t, vec2 p0, vec2 p1){\n    return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);\n}\nfloat valueFromLineSegs(float time, float frameStart, float frameCount){\n    int start = int(frameStart);\n    int count = int(frameCount - 1.);\n    int end = start + count;\n    for (int i = 0;i < MAX_C;i++){\n        #ifdef NONE_CONST_INDEX\n        if (i > count){\n            return lookup_curve(i).w;\n        }\n            #else\n        if (i<start){\n            continue;\n        }\n        if (i > end){\n            return lookup_curve(i-2).w;\n        }\n            #endif\n\n            #ifdef NONE_CONST_INDEX\n        vec4 seg = lookup_curve(i+start);\n        #else\n        vec4 seg = lookup_curve(i);\n        #endif\n        vec2 p0 = seg.xy;\n        vec2 p1 = seg.zw;\n        if (time >= p0.x && time <= p1.x){\n            return evaluteLineSeg(time, p0, p1);\n        }\n            #ifdef NONE_CONST_INDEX\n        vec2 p2 = lookup_curve(i+start+1).xy;\n        #else\n        vec2 p2 = lookup_curve(i+1).xy;\n        #endif\n        if (time > p1.x && time <= p2.x){\n            return evaluteLineSeg(time, p1, p2);\n        }\n    }\n    return lookup_curve(0).y;\n}\n    #endif\n\nfloat getValueFromTime(float time, vec4 value){\n    float type = value.x;\n    if (type == 0.){\n        return value.y;\n    }\n    else if (type == 1.){\n        return mix(value.y, value.z, time / value.w);\n    }\n        #ifdef USE_LINE_SEG\n    if (type == 3.){\n        return valueFromLineSegs(time, value.y, value.z);\n    }\n        #endif\n        #ifdef USE_CURVE_VALUE\n    if (type == 2.){\n        return valueFromCurveFrames(time, value.y, value.z);\n    }\n        #endif\n    if (type == 4.){\n        #ifdef SHADER_VERTEX\n        float seed = aSeed;\n        #else\n        float seed = vSeed;\n        #endif\n        return mix(value.y, value.z, seed);\n    }\n    return 0.;\n}\n\nattribute vec4 aPos;\nattribute vec3 aDir;\nattribute vec4 aInfo;//start lifetime section side\nattribute vec4 aColor;\nattribute float aTrailStart;\n\nuniform mat3 uCameraDir;\nuniform mat4 uModel;\nuniform mat4 uViewProjection;\n\nuniform float uTime;\nuniform vec4 uParams;//??? sectionCount\nuniform vec4 uColorParams;//mask opacityOverLifetime\nuniform vec4 uOpacityOverLifetimeValue;\n\nuniform vec4 uWidthOverTrail;\n#ifdef COLOR_OVER_TRAIL\nuniform sampler2D uColorOverTrail;\n#endif\n\n#ifdef COLOR_OVER_LIFETIME\nuniform sampler2D uColorOverLifetime;\n#endif\nvarying float vLife;\nvarying vec2 vTexCoord;\nvarying vec4 vColor;\n\nvoid main() {\n    vec4 _pa = uViewProjection  * vec4(aPos.xyz, 1.);\n    vec4 _pb = uViewProjection  * vec4(aPos.xyz + aDir, 1.);\n    vec2 dir = normalize(_pb.xy/_pb.w - _pa.xy/_pa.w);\n    vec2 screen_xy = vec2(-dir.y, dir.x);\n    vec4 pos = uModel * vec4(aPos.xyz, 1.);\n    float trail = 1. - (aInfo.z - aTrailStart) / uParams.y;\n    float width = aPos.w * getValueFromTime(trail, uWidthOverTrail) / max(abs(screen_xy.x), abs(screen_xy.y));\n    pos.xyz += (uCameraDir[0] * screen_xy.x + uCameraDir[1] * screen_xy.y) * width;\n\n    gl_Position = uViewProjection * pos;\n\n    float time  = clamp((uTime - aInfo.x)/aInfo.y, 0.0, 1.0);\n\n    vColor = aColor;\n\n    #ifdef COLOR_OVER_LIFETIME\n    #ifdef ENABLE_VERTEX_TEXTURE\n    vColor *= texture2D(uColorOverLifetime, vec2(time, 0.));\n    #endif\n    #endif\n\n    #ifdef COLOR_OVER_TRAIL\n    vColor *= texture2D(uColorOverTrail, vec2(trail, 0.));\n    #endif\n\n    if (uColorParams.y >0.0){\n        vColor.a *= clamp(getValueFromTime(time, uOpacityOverLifetimeValue),0.,1.);\n    }\n\n    vLife = time;\n    vTexCoord = vec2(trail, aInfo.w);\n    vSeed = aSeed;\n}\n"},function(e,t,n){"use strict";function r(e){for(var t=arguments,n=function(n){var r=t[n];r&&Object.keys(r).forEach((function(t){e[t]=r[t]}))},r=1;r<arguments.length;r++)n(r);return e}function i(e,t){return(t||document).querySelector(e)}function a(e,t){if("string"==typeof e){var n=e;e=new Image,t||/^data:/.test(n)||(e.crossOrigin="*"),e.src=n}return e.complete?Promise.resolve(e):new Promise((function(t,n){e.addEventListener("load",(function(){return t(e)})),e.addEventListener("error",(function(e){return n(e)}))}))}function o(e,t){var n=e.indexOf(t);if(n>-1)return e.splice(n,1),!0}function u(e,t,n){if(s(e))if(void 0===n&&(n=e),e instanceof Array||"length"in e)Array.prototype.slice.call(e).forEach(t,n);else for(var r in e)e.hasOwnProperty(r)&&t.call(n,e[r],r);return e}function f(e){return"function"==typeof e}function s(e){return"object"==typeof e&&e}function l(e){return"string"==typeof e}function c(){}n.r(t),Array.prototype.find||(Array.prototype.find=function(e,t){for(var n=t||this,r=0;r<this.length;r++){var i=this[r];if(e.call(n,i,r))return i}},Array.prototype.findIndex=function(e,t){for(var n=t||this,r=0;r<this.length;r++){var i=this[r];if(e.call(n,i,r))return r}});function d(e,t){return e+Math.random()*(t-e)}function v(e,t){var n=t?t.responseType:"json";return new Promise((function(t,r){var i=new XMLHttpRequest;i.responseType=n,i.addEventListener("load",(function(){return t(i.response)})),i.addEventListener("error",r),i.open("get",e),i.send()}))}var m=n(0);function _(e,t){return e.map((function(e,n){return e+t[n]}))}function E(e,t){return e.map((function(n,r){return e[r]-t[r]}))}Math.pow(2,-32);function p(e){for(var t=0,n=0;n<e.length;n++)t+=e[n]*e[n];return 0===(t=Math.sqrt(t))?e.slice():e.map((function(e){return e/t}))}function h(e,t){if(isNaN(t)){for(var n=0,r=0;r<e.length;r++)n+=e[r]*t[r];return n}return e.map((function(e){return e*t}))}function y(e,t){var n=e[0],r=e[1],i=e[2];return[n*t[0]+r*t[3]+i*t[6],n*t[1]+r*t[4]+i*t[7],n*t[2]+r*t[5]+i*t[8]]}function R(e){var t,n;return t=Math.sin(e),[n=Math.cos(e),t,0,-t,n,0,0,0,1]}function C(e){var t=Math.cos(e[0]),n=Math.cos(e[1]),r=Math.cos(e[2]),i=Math.sin(e[0]),a=Math.sin(e[1]),o=Math.sin(e[2]);return[n*r,n*o,-a,-t*o+i*a*r,t*r+i*a*o,i*n,o*i+t*a*r,-i*r+t*a*o,t*n]}var T=function(){function e(e){r(this,e)}return e.prototype.generate=function(e){var t=g(this.arc,this.arcMode,e)*k,n=[Math.cos(t)*this.radius,Math.sin(t)*this.radius,0];return{position:n,direction:p(_([0,0,1],h(n,Math.tan(this.angle*k))))}},e}();function g(e,t,n){if(t===N)e=d(0,e);else if(t===S){var r=n.index%(n.total+1);e=e/n.total*r}else if(t===U){var i=n.index/(n.total+1),a=i-Math.floor(i);e*=Math.floor(i)%2?1-a:a}else t===I&&(e*=n.burstIndex);return e}var x=function(){function e(e){r(this,e)}var t=e.prototype;return t.getHorizontalAngle=function(){return d(-90,90)},t.generate=function(e){var t=g(this.arc,this.arcMode,e)*k,n=this.getHorizontalAngle()*k,r=this.radius,i=y([Math.cos(n),0,Math.sin(n)],R(t));return{position:i.map((function(e){return e*r})),direction:i}},e}(),O=function(e){var t,n;function r(){return e.apply(this,arguments)||this}return n=e,(t=r).prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n,r.prototype.getHorizontalAngle=function(){return d(0,90)},r}(x),V=function(){function e(e){r(this,e)}return e.prototype.generate=function(e){var t=g(this.arc,this.arcMode,e)*k,n=[Math.cos(t),Math.sin(t),0],r=this.radius;return{direction:n,position:n.map((function(e){return e*r}))}},e}(),L=function(){function e(e){this._d=(e.width||1)/2,this._h=(e.height||1)/2}return e.prototype.generate=function(e){return{direction:[0,0,1],position:[d(-this._d,this._d),d(-this._h,this._h),0]}},e}(),A=function(){function e(e){this._d=(e.width||1)/2}return e.prototype.generate=function(e){return{direction:[0,1,0],position:[d(-this._d,this._d),0,0]}},e}(),N=0,S=1,U=2,I=3,D={Cone:T,Sphere:x,Hemisphere:O,Circle:V,Donut:function(){function e(e){r(this,e)}return e.prototype.generate=function(e){var t=this.donutRadius,n=this.radius-t,r=d(0,M),i=R(g(this.arc,this.arcMode,e)*k);return{direction:y([Math.cos(r),Math.sin(r),0],i),position:y([n+Math.cos(r)*t,0,Math.sin(r)*t],i)}},e}(),Rectangle:L,Edge:A},k=Math.PI/180,M=2*Math.PI,P=function(){function e(){}return e.prototype.generate=function(){return{position:[0,0,0],direction:[0,0,0]}},e}();function w(e){if(!e)return new P;var t=r({radius:1,arc:360,angle:0,arcMode:N},e||{}),n=D[e.shape];if(!n)throw Error("invalid shape:"+e.shape);return new n(t)}function F(e){l(e)&&(e=Y(e));for(var t=X(1,1),n=t.data,r=0;r<4;r++)n[r]=e[r];return t}function B(e,t){var n=[];if(u(e,(function(e,r){return n.push({color:Y(e,t),stop:G(r)})})),(n=n.sort((function(e,t){return e.stop-t.stop}))).length){0!==n[0].stop&&n.unshift({stop:0,color:n[0].color.slice()});var r=n[n.length-1];1!==r.stop&&n.push({stop:1,color:r.color.slice()})}return n}function X(e,t){return"undefined"!=typeof ImageData?new ImageData(e,t):{width:e,height:t,data:new Uint8Array(e*t*4)}}function b(e){var t=X(128,1),n=t.data,r=B(e);if(r.length)for(var i=0;i<128;i++){for(var a=i/128,o=void 0,u=void 0,f=0;f<r.length&&(o=r[f],u=r[f+1],!(o.stop<=a&&u.stop>a));f++);var s=z(o.color,u.color,(a-o.stop)/(u.stop-o.stop));n.set(s,4*i)}return t}function z(e,t,n){for(var r=[],i=1-n,a=0;a<3;a++)r[a]=Math.round(Math.sqrt(e[a]*e[a]*i+t[a]*t[a]*n));return r[3]=Math.round(e[3]*i+t[3]*n),r}function Y(e,t){var n;if(l(e)){e=e.replace(/[\s\t\r\n]/g,"");var r=/rgba?\(([.\d]+),([.\d]+),([.\d]+),?([.\d]+)?\)/.exec(e);if(r){var i=+r[4];n=[+r[1],+r[2],+r[3],isNaN(i)?255:255*i]}else/^#[a-f\d]{3}$/i.test(e)?n=[parseInt(e[1]+e[1],16),parseInt(e[2]+e[2],16),parseInt(e[3]+e[3],16),255]:(r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e))&&(n=[parseInt(r[1],16),parseInt(r[2],16),parseInt(r[3],16),255]||!1)}else e instanceof Array&&(n=[e[0],e[1],e[2],isNaN(e[3])?255:255*e[3]]);if(t)for(var a=0;a<4;a++)n[a]/=255;return n}function G(e){var t=/^(-)?([\d+.]+)%$/.exec(e);return t?+t[2]/100*(t[1]?-1:1):+e}function H(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e.__proto__=t}function W(e){return Array.isArray(e)&&l(e[0])?e[1]:e}var j={random:function(e){return e[0]instanceof Array?new Q(e):new J(e)},static:function(e){return new q(e)},constant:function(e){return new q(e)},curve:function(e){return new oe(e)},linear:function(e){return new ee(e)},randomSet:function(e){return new $(e)},color:function(e){return new q(Y(e,!0))},colors:function(e){return new $(e.map((function(e){return Y(e,!0)})))},lines:function(e){return 2===e.length&&0===e[0][0]&&1===e[1][0]?new ee([e[0][1],e[1][1]]):new ue(e)},gradient:function(e){return new te(e)}};function Z(e){return!e||+e?new q(e||0):j[e[0]](e[1])}var K=function(){function e(e){this.onCreate(e)}var t=e.prototype;return t.onCreate=function(e){throw Error()},t.getIntegrateValue=function(e,t){throw Error()},t.getIntegrateByTime=function(e,t){throw Error()},t.getValue=function(e){throw Error()},t.toUniform=function(e){throw Error()},t.map=function(e){throw Error()},t.scaleXCoord=function(e){return this},e}(),q=function(e){function t(){return e.apply(this,arguments)||this}H(t,e);var n=t.prototype;return n.onCreate=function(e){this._value=e},n.getIntegrateValue=function(e,t){return this._value*(t-e)},n.getIntegrateByTime=function(e,t){return.5*this._value*(t*t-e*e)},n.getValue=function(e){return this._value},n.toUniform=function(e){return new Float32Array([0,this._value,0,0])},n.map=function(e){var t=this._value;return t instanceof Array?this._value=t.map(e):this._value=e(t),this},t}(K),$=function(e){function t(){return e.apply(this,arguments)||this}H(t,e);var n=t.prototype;return n.onCreate=function(e){this._items=e},n.getValue=function(e){var t=this._items;return t[Math.floor(Math.random()*t.length)]},n.map=function(e){return this._items=this._items.map(e),this},t}(K),J=function(e){function t(){return e.apply(this,arguments)||this}H(t,e);var n=t.prototype;return n.onCreate=function(e){this._min=e[0],this._max=e[1]},n.getValue=function(e){return d(this._min,this._max)},n.toUniform=function(e){return new Float32Array([4,this._min,this._max,0])},n.map=function(e){return this._min=e(this._min),this._max=e(this._max),this},t}(K),Q=function(e){function t(){return e.apply(this,arguments)||this}H(t,e);var n=t.prototype;return n.onCreate=function(e){this._min=e[0],this._max=e[1]},n.getValue=function(e){for(var t=this._min,n=this._max,r=[],i=0;i<t.length;i++){var a=Math.random();r[i]=t[i]*(1-a)+n[i]*a}return r},n.map=function(e){return this._min=this._min.map(e),this._max=this._max.map(e),this},t}(K),ee=function(e){function t(){return e.apply(this,arguments)||this}H(t,e);var n=t.prototype;return n.onCreate=function(e){this._min=e[0],this._max=e[1],this._xCoord=1},n.getValue=function(e){return e/=this._xCoord,this._min*(1-e)+this._max*e},n.toUniform=function(){return new Float32Array([1,this._min,this._max,this._xCoord])},n.getIntegrateValue=function(e,t){var n=this._min;return e/=this._xCoord,((t/=this._xCoord)-e)*((this._max-n)*(t+e)/2+n)},n.getIntegrateByTime=function(e,t){var n=this._max-this._min,r=this._min;return e/=this._xCoord,n*(t/=this._xCoord)*t*t/3-n*e*e*e/3-r*e*e/2+r*t*t/2},n.map=function(e){return this._min=e(this._min),this._max=e(this._max),this},n.scaleXCoord=function(e){return this._xCoord=e,this},t}(K),te=function(e){function t(){return e.apply(this,arguments)||this}H(t,e);var n=t.prototype;return n.onCreate=function(e){this.stops=B(e,!0)},n.getValue=function(e){for(var t=this.stops,n=t.length-1,r=0;r<n;r++){var i=t[r],a=t[r+1];if(i.stop<=e&&a.stop>e){var o=(e-i.stop)/(a.stop-i.stop);return z(i.color,a.color,o)}}return n.color.slice()},t}(K),ne=0,re=1,ie=2,ae=3,oe=function(e){function t(){return e.apply(this,arguments)||this}H(t,e);var n=t.prototype;return n.onCreate=function(e){this.keys=e.map((function(e){if(e instanceof Array)return e.slice(0,4);if(s(e))return[e.time,e.value,e.inTangent||0,e.outTangent||0];throw Error("invalid keyframe")})).sort((function(e,t){return e[ne]-t[ne]})),this.isCurveValue=!0},n.getValue=function(e){var t=this.keys;if(e<=t[0][ne])return t[0][re];for(var n=t.length-1,r=0;r<n;r++){var i=t[r],a=t[r+1];if(e>i[ne]&&e<=a[ne])return le(e,i,a)}return t[n][re]},n.getIntegrateByTime=function(e,t){return this._integrate(t,!0)-this._integrate(e,!0)},n.getIntegrateValue=function(e,t){return this._integrate(t)-this._integrate(e)},n._integrate=function(e,t){var n=this.keys;if(e<=n[0][ne])return 0;for(var r=0,i=n.length-1,a=t?de:ce,o=0;o<i;o++){var u=n[o],f=n[o+1];if(e>u[ne]&&e<=f[ne])return r+a(e,u,f);r+=a(f[ne],u,f)}return r},n.toData=function(){for(var e=this.keys,t=new Float32Array(4*e.length),n=0,r=0;n<e.length;n++,r+=4)t.set(e[n],r);return t},n.toUniform=function(e){var t=e.index,n=this.keys;return e.curves.push(this),e.index+=n.length,e.max=Math.max(e.max,n.length),e.curveCount+=n.length,new Float32Array([2,t,n.length,0])},n.map=function(e){return this.keys.forEach((function(t){return t[re]=e(t[re])})),this},n.scaleXCoord=function(e){return this.keys.forEach((function(t){return t[ne]=e*t[ne]})),this},t.getAllData=function(e){for(var t=new Float32Array(4*e.index),n=0,r=0,i=e.curves;n<i.length;n++){var a=i[n].toData();t.set(a,r),r+=a.length}return t},t}(K),ue=function(e){function t(){return e.apply(this,arguments)||this}H(t,e);var n=t.prototype;return n.onCreate=function(e){this.keys=e.map((function(e){return e.slice(0,2)})).sort((function(e,t){return e[0]-t[0]})),this.isLineSeg=!0},n.getValue=function(e){var t=this.keys;if(e<t[0][0])return t[0][1];for(var n=t.length-1,r=0;r<n;r++){var i=t[r],a=t[r+1],o=i[0],u=a[0];if(e>=o&&e<=u){var f=(e-o)/(u-o),s=i[1];return s+f*(a[1]-s)}}return t[n][1]},n.getIntegrateValue=function(e,t){return this._integrate(t)-this._integrate(e)},n.getIntegrateByTime=function(e,t){return this._integrate(t,!0)-this._integrate(e,!0)},n._integrate=function(e,t){var n=this.keys;if(e<=n[0][0])return 0;for(var r=0,i=n.length-1,a=t?se:fe,o=0;o<i;o++){var u=n[o],f=n[o+1],s=u[0],l=f[0];if(e>s&&e<=l)return r+a(e,s,l,u[1],f[1]);r+=a(l,s,l,u[1],f[1])}return r},n.toData=function(){for(var e=this.keys,t=new Float32Array(4*Math.ceil(e.length/2)),n=0,r=0;n<e.length;n++,r+=2)t.set(e[n],r);return t.set(e[e.length-1],t.length-2),t},n.toUniform=function(e){var t=e.index,n=this.keys,r=Math.ceil(n.length/2);return e.lineSegCount+=r,e.curves.push(this),e.index+=r,e.max=Math.max(e.max,r),new Float32Array([3,t,r,0])},n.map=function(e){return this.keys.forEach((function(t){return t[1]=e(t[1])})),this},n.scaleXCoord=function(e){return this.keys.forEach((function(t){return t[0]=e*t[0]})),this},t}(K);function fe(e,t,n,r,i){var a=e-t;return(r+r+(i-r)*a/(n-t))*a/2}function se(e,t,n,r,i){var a=e*e,o=t*t;return(2*(a*e)*(r-i)+3*a*(t*i-n*r)-o*t*(2*r+i)+3*o*n*r)/(6*(t-n))}function le(e,t,n){var r=n[ne]-t[ne],i=t[ae]*r,a=n[ie]*r,o=(e-t[ne])/r,u=o*o,f=u*o,s=f-2*u+o,l=f-u,c=-2*f+3*u;return(2*f-3*u+1)*t[re]+s*i+l*a+c*n[re]}function ce(e,t,n){var r=n[ne]-t[ne],i=t[ae]*r,a=n[ie]*r,o=t[ne],u=t[re],f=n[re],s=o-e,l=s*s,c=l*s;return(i+a+2*u-2*f)*c*s/(4*r*r*r)+(2*i+a+3*u-3*f)*c/(3*r*r)+i*l/2/r-u*s}function de(e,t,n){var r=n[ne]-t[ne],i=t[ae]*r,a=n[ie]*r,o=t[ne],u=t[re],f=n[re],s=o-e,l=s*s,c=l*s,d=r*r,v=d*r;return(-30*v*u*(o+e)*s+10*d*i*(o+2*e)*l+5*r*(o+3*e)*(2*i+a+3*u-3*f)*c+3*(o+4*e)*(i+a+2*u-2*f)*c*s)/60/v}var ve=n(1);function me(e,t,n){return e.geometry[n.name]}function _e(e,t){e===ve.BLEND_MODE_ADDITIVE||e===ve.BLEND_MODE_SUBTRACT?(t.blendSrc=m.constants.SRC_ALPHA,t.blendDst=m.constants.ONE,e===ve.BLEND_MODE_SUBTRACT&&(t.blendEquationAlpha=t.blendEquation=m.constants.FUNC_REVERSE_SUBTRACT,t.blendDstAlpha=m.constants.ONE,t.blendSrcAlpha=m.constants.ONE)):e===ve.BLEND_MODE_MULTIPLY?(t.blendSrc=m.constants.DST_COLOR,t.blendDst=m.constants.ONE_MINUS_SRC_ALPHA):(t.blendSrc=m.constants.SRC_ALPHA,t.blendDst=m.constants.ONE_MINUS_SRC_ALPHA)}function Ee(){return{isDependMesh:!0,get:function(){return function(){if(!m.semantic.g_particle){var e=m.semantic.camera.viewMatrix.elements;m.semantic.g_particle={uCameraDir:new Float32Array([e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]])}}}(),m.semantic.g_particle.uCameraDir}}}function pe(){m.semantic.g_particle=null}function he(e,t){u(e,(function(e){e&&(e.isDataTexture||e.isTexture&&t)&&e.destroy()}))}function ye(e,t,n,r){if(void 0===n&&(n=1),e.buffer.byteLength<e.BYTES_PER_ELEMENT*t){var i=t*n;isNaN(r)||(i=Math.min(i,r));var a=new ArrayBuffer(e.BYTES_PER_ELEMENT*i),o=new e.constructor(a);return o.set(e),o}return e}function Re(e,t){var n={};return(t=t||{}).clamp?n.wrapS=n.wrapT=m.constants.MIRRORED_REPEAT:n.wrapS=n.wrapT=m.constants.REPEAT,"string"==typeof e&&e.length?"#"===e[0]?Ce(F(e)):(n.src=e,new m.LazyTexture(n)):e instanceof Image||e instanceof ImageData||e instanceof HTMLCanvasElement?(n.image=e,new m.Texture(n)):(e&&e.isTexture&&r(e,n),e)}function Ce(e,t){return t=t||{},new m.Texture({image:e||F("#fff"),type:t.type||m.constants.UNSIGNED_BYTE,format:t.format||m.constants.RGBA,internalFormat:t.format||m.constants.RGBA,wrapS:m.constants.CLAMP_TO_EDGE,wrapT:m.constants.CLAMP_TO_EDGE,minFilter:m.constants.NEAREST,magFilter:m.constants.NEAREST})}function Te(e,t,n){return e[n.name]}function ge(e){return new m.Texture({image:b(e),wrapS:m.constants.CLAMP_TO_EDGE,wrapT:m.constants.CLAMP_TO_EDGE,minFilter:m.constants.NEAREST,magFilter:m.constants.NEAREST})}function xe(e){var t=new FileReader;return new Promise((function(n,r){t.readAsDataURL(e),t.onload=function(){return n(t.result)},t.onerror=r}))}function Oe(e,t,n,r){var i={},o=[],f=r instanceof HTMLCanvasElement;return n=n||{},u(t.variables,(function(e,t){n.hasOwnProperty(t)&&(e=n[t]),/^image_/.test(t)&&/^(https?:)?\/\//.test(e)?o.push(v(e,{responseType:"blob"}).then(xe,(function(){return e})).then((function(e){return i[t]=e}))):i[t]=e})),Promise.all(o).then((function(){return a(e).then((function(e){var n=t.content.replace(/\$([\w_]+)\$/g,(function(e,t){return i[t]||t}));return a("data:image/svg+xml,"+encodeURIComponent(n)).then((function(n){(r=r||document.createElement("canvas")).width=e.width,r.height=e.height;var i=r.getContext("2d");return i.clearRect(0,0,e.width,e.height),i.drawImage(e,0,0),i.drawImage(n,0,0,n.width,n.height,0,0,n.width/t.backgroundWidth*e.width,n.height/t.backgroundHeight*e.height),f?r:r.toDataURL()}))}))}))}var Ve=n(3),Le=n.n(Ve),Ae=n(2),Ne=n.n(Ae),Se=n(4),Ue=n.n(Se),Ie=n(5),De=n.n(Ie),ke=n(6),Me=n.n(ke),Pe=n(7),we=n.n(Pe),Fe=n(8),Be=n.n(Fe),Xe={dissolve:{program:Ue.a,uniforms:{uClipPoint:{name:"center",default:[.5,.5]}},variables:{uStrengthValue:["strength",1]},textures:{uBlend:{src:"blend"},uNoise:{src:"noise"}}},reflect:{program:De.a,uniforms:{uFlipDir:{name:"direction",default:[1,1],enum:{1:[-1,1],2:[1,-1],3:[-1,-1]}}},variables:{uOpacityOverYValue:["opacityOverY",1],uOpacityOverXValue:["opacityOverX",1],uDisplayMinXValue:["displayMinX",0],uDisplayMinYValue:["displayMinY",0],uDisplayMaxXValue:["displayMaxX",1],uDisplayMaxYValue:["displayMaxY",1]}},swirl:{program:Me.a,uniforms:{uCenter:{name:"center",default:[.5,.5]}},variables:{uRadiusValue:["radius",1],uAngleValue:["angle",180],uBlendOpacityValue:["blendOpacity",0],uStrengthValue:["strength",1]},textures:{uBlend:{src:"blend"}}},wave:{program:we.a,uniforms:{uWaveParams:function(e){var t=e.center||[.5,.5];return[t[0],t[1],e.waveFrequency||4,e.blendMethod||0]}},variables:{uWaveMovementValue:["waveMovement",0],uWaveHeightValue:["waveHeight",.1],uWaveDampingValue:["waveDamping",1],uBlendOpacityValue:["blendOpacity",0]},textures:{uBlend:{src:"blend"}}},mask:{program:Be.a,variables:{uTextureOffsetX:["texOffsetX",0],uTextureOffsetY:["texOffsetY",0]},textures:{uBlend:function(e){return new m.LazyTexture({src:e.blend,wrapS:e.repeatX?m.constants.REPEAT:m.constants.CLAMP_TO_EDGE,wrapT:e.repeatY?m.constants.REPEAT:m.constants.CLAMP_TO_EDGE})}}}};var be,ze=function(){var e=document.createElement("canvas").getContext("webgl");this.floatTexture=!!e.getExtension("OES_texture_float"),this.halfFloatTexture=!!e.getExtension("OES_texture_half_float"),this.maxVertexUniforms=e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),this.maxFragmentUniforms=e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),this.maxVertexTextures=e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)};function Ye(e){return be||(be=new ze),be[e]}function Ge(e,t){return be||(be=new ze),be[e]=t}var He,We,je=1;function Ze(e){He=e}function Ke(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var qe=function(e){var t,n;function r(t){var n,r,i=["#define RENDER_MODE "+t.renderMode],a=[],o=[],l=0,c={curves:[],index:0,max:0,lineSegCount:0,curveCount:0},d={curves:[],index:0,max:0,lineSegCount:0,curveCount:0},v=Ye("maxVertexTextures")>0;v&&i.push("#define ENABLE_VERTEX_TEXTURE 1"),t.sprite&&t.sprite.animate&&(i.push("#define USE_SPRITE"),l|=4),t.filter&&t.filter.name!==ve.FILTER_NAME_NONE&&(i.push("#define USE_FILTER 1"),l|=8,r=function(e,t){var n=Xe[e.name];if(!n)throw Error("invalid filter name:"+e.name);var r={},i={},a={program:n.program,uniforms:r,name:e.name},o={isDependMesh:!0,get:function(e,t,n){return m.semantic.handlerTexture(i[n.name],n.textureIndex)}},l={isDependMesh:!0,get:function(e,t,n){return i[n.name]}};return u(n.variables,(function(n,a){var o=e[n[0]];void 0===o&&(o=n[1]),i[a]=Z(o).toUniform(t),r[a]=l})),u(n.uniforms,(function(t,n){var o;if(f(t))o=t(e);else if(s(t)){var u=e[t.name],c=t.enum;c&&(o=c[u]),void 0===o&&(o=t.default)}else o=W(e[t]);if(Number.isFinite(o))i[n]=o;else{if(!s(o)||!f(o.slice))throw Error("invalid value for:"+n+"->"+t);i[n]=o.slice()}return r[n]=l,a})),u(n.textures,(function(t,n){f(t)?i[n]=t(e):i[n]=new m.LazyTexture({src:e[t.src],wrapS:t.wrapS||m.constants.CLAMP_TO_EDGE,wrapT:t.wrapT||m.constants.CLAMP_TO_EDGE}),r[n]=o})),a}(t.filter,d));var _=t.colorOverLifetime;_.color&&(i.push("#define COLOR_OVER_LIFETIME"),l|=16);var E=_.opacity;t.uOpacityOverLifetimeValue=E?E.toUniform(c):new Float32Array(4);var p,h=t.linearVelOverLifetime,y=t.orbitalVelOverLifetime;["x","y","z"].forEach((function(e,n){var r=0;h[e]&&(t["uLinear"+e.toUpperCase()+"ByLifetimeValue"]=h[e].toUniform(c),r=1,l|=1<<7+n,h.enabled=!0),i.push("#define LINEAR_VEL_"+e.toUpperCase()+" "+r);var a=0;y[e]&&(t["uOrb"+e.toUpperCase()+"ByLifetimeValue"]=y[e].toUniform(c),a=1,l|=1<<10+n,p=!0,y.enabled=!0),i.push("#define ORB_VEL_"+e.toUpperCase()+" "+a)})),h.asMovement&&(i.push("#define AS_LINEAR_MOVEMENT"),l|=32),p&&(y.asRotation&&(i.push("#define AS_ORBITAL_MOVEMENT"),l|=64),t.uOrbCenter=new Float32Array(y.center||3));var R=t.sizeOverLifetime;R&&(i.push("#define SIZE_BY_LIFE 1"),l|=8192,t.uSizeByLifetimeValue=R.x.toUniform(c),R.separateAxes&&(i.push("#define SIZE_Y_BY_LIFE 1"),l|=16384,t.uSizeYByLifetimeValue=R.y.toUniform(c)));var C=t.rotationOverLifetime;C.z&&(t.uRZByLifeTimeValue=C.z.toUniform(c),l|=32768,i.push("#define ROT_Z_LIFETIME 1")),C.x&&(t.uRXByLifeTimeValue=C.x.toUniform(c),l|=65536,i.push("#define ROT_X_LIFETIME 1")),C.y&&(t.uRYByLifeTimeValue=C.y.toUniform(c),l|=1<<17,i.push("#define ROT_Y_LIFETIME 1")),C.asRotation&&(i.push("#define ROT_LIFETIME_AS_MOVEMENT 1"),l|=1<<18);var T=t.gravity;t.acceleration=[T[0]||0,T[1]||0,T[2]||0,0],t.uGravityModifierValue=t.gravityModifier.toUniform(c);var g=Ye("floatTexture");g&&d.max?(l|=1<<19,t.uFCurveValueTexture=new m.DataTexture({image:oe.getAllData(d),width:d.index,height:1}),o.push("#define LOOKUP_TEXTURE_CURVE 1")):t.uFCurveValues=oe.getAllData(d);var x,O,V=Ye("maxVertexUniforms");if(t.uVCurveValues=oe.getAllData(c),c.max+c.curves.length-32>V&&c.max&&(g&&v&&(t.uVCurveValueTexture=new m.DataTexture({image:t.uVCurveValues,width:c.max,height:1}),a.push("#define LOOKUP_TEXTURE_CURVE 1")),x=je,O={name:t.name},He&&He(x,O),console.error("report error:"+x+"\n"+JSON.stringify(O||{}))),t.previewBorder){var L="#define PREVIEW_BORDER 1";o.push(L),a.push(L),t.uPreviewColor=new Float32Array(t.previewBorder),l|=1<<20}a.push("#define CURVE_VALUE_COUNT "+c.index),o.push("#define CURVE_VALUE_COUNT "+d.index),a.push("#define MAX_KEY_FRAME_COUNT "+c.max),o.push("#define MAX_KEY_FRAME_COUNT "+d.max),c.lineSegCount&&(a.push("#define USE_LINE_SEG"),l|=1<<21),d.lineSegCount&&(o.push("#define USE_LINE_SEG"),l|=1<<22),c.curveCount&&(a.push("#define USE_CURVE_VALUE"),l|=1<<23),d.curveCount&&(o.push("#define USE_CURVE_VALUE"),l|=1<<24),l=["p",t.renderMode,l,c.index,c.max,d.index,d.max].join("+");var A={get:me},N={isDependMesh:!0,get:function(e,t,n){return m.semantic.handlerTexture(e[n.name],n.textureIndex)}},S={isDependMesh:!0,get:Te},U=i.join("\n"),I={vs:a.join("\n")+"\n"+U+"\n"+Le.a,fs:o.join("\n")+"\n"+U+"\n"+Ne.a,shaderCacheId:l,transparent:!0,side:t.side,depthMask:t.occlusion,depthTest:!0,castShadows:!1,renderOrder:t.order,uniforms:{uViewProjection:"VIEWPROJECTION",uCameraDir:Ee(),uModel:{isDependMesh:!0,get:function(e){return e.matrix.elements}},uVCurveValueTexture:N,uFCurveValueTexture:N,uVCurveValues:S,uFCurveValues:S,uRZByLifeTimeValue:S,uRYByLifeTimeValue:S,uRXByLifeTimeValue:S,uLinearXByLifetimeValue:S,uLinearYByLifetimeValue:S,uLinearZByLifetimeValue:S,uOrbXByLifetimeValue:S,uOrbYByLifetimeValue:S,uOrbZByLifetimeValue:S,uGravityModifierValue:S,uSizeByLifetimeValue:S,uSizeYByLifetimeValue:S,uPreviewColor:S,uColorParams:S,uAcceleration:S,uOrbCenter:S,uSprite:S,uOpacityOverLifetimeValue:S,uTexOffset:{isDependMesh:!0,get:function(e,t,n){var r=e.diffuse;return r?new Float32Array([1/r.width,1/r.height]):new Float32Array([0,0])}},uMaskTex:{isDependMesh:!0,get:function(e,t,n){return m.semantic.handlerTexture(e.diffuse,n.textureIndex)}},uColorOverLifetime:N,uParams:{isDependMesh:!0,get:function(e){return new Float32Array([e.time,e.duration,e.particleLastingTime,0])}}},attributes:{aSprite:A,aPos:A,aVel:A,aTime:A,aRot:A,aColor:A,aOffset:A,aSeed:A}};if(r){var D=I.uniforms;u(r.uniforms,(function(e,t){if(D[t])throw Error("conflict uniform name:"+t);D[t]=e})),I.fs=I.fs.replace("#pragma FILTER",r.program),I.shaderCacheId+=r.name}var k=new m.ShaderMaterial(I);return _e(t.blending,k),t.material=k,t.geometry=new m.Geometry({isStatic:!1,mode:4}),t.time=0,t.diffuse=t.mask||Ce(),(n=e.call(this,t)||this)._geometry(),n.uColorParams=new Float32Array([t.mask?1:0,_.opacity?1:0,t.blending===ve.BLEND_MODE_LUMINANCE_ALPHA,0]),_.color&&(n.uColorOverLifetime=ge(_.color)),n}n=e,(t=r).prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n;var i,a,o,l=r.prototype;return l._geometry=function(){var e=this.geometry;e.aPos=new m.GeometryData(new Float32Array(0),3),e.aVel=new m.GeometryData(new Float32Array(0),3),e.aRot=new m.GeometryData(new Float32Array(0),3),e.aColor=new m.GeometryData(new Float32Array(0),4),e.aOffset=new m.GeometryData(new Float32Array(0),4),e.indices=new m.GeometryData(new Uint32Array(0),1),e.aTime=new m.GeometryData(new Float32Array(0),2),e.aSeed=new m.GeometryData(new Float32Array(0),1),this._useSprite&&(e.aSprite=new m.GeometryData(new Float32Array(0),3)),this.particleCount=0},l.getPointSize=function(e){return this.geometry.aOffset.data[16*e+3]},l.getPointStartTime=function(e){return this.geometry.aTime.data[8*e]},l.getPointColor=function(e){var t=this.geometry.aColor.data,n=16*e;return[t[n],t[n+1],t[n+2],t[n+3]]},l.getPointPosition=function(e,t){for(var n=this.geometry,r=n.aPos.data,i=12*e,a=n.aVel.data,o=this.time-n.aTime.data[8*e],u=[],f=this.uAcceleration,s=t.getIntegrateByTime(0,o),l=o/n.aTime.data[8*e+1],c=0;c<3;c++)u[c]=r[i+c]+a[i+c]*o+f[c]*s;var d=this.linearVelOverLifetime,v=this.orbitalVelOverLifetime,m=["x","y","z"];if(v.enabled){var _=v.center||[0,0,0],E=[u[0]-_[0],u[1]-_[1],u[2]-_[2]],p=v.asRotation;u=y(E,C(m.map((function(e){var t=v[e];return t?p?t.getValue(l):t.getIntegrateValue(0,l):0}))))}if(d.enabled)for(var h=d.asMovement,R=0;R<3;R++){var T=d[m[R]];T&&(u[R]+=h?T.getValue(l):T.getIntegrateValue(0,l))}return u},l.clearPoints=function(){var e=this.geometry;u(e,(function(e,t){if(e.isGeometryData){var n=e.data;n&&(e.data=new n.constructor(0))}})),this.particleCount=e.vertexCount=this.maxParticleBufferCount=0},l.reverseTime=function(e){for(var t=this.geometry.aTime,n=t.data,r=0;r<n.length;r+=2)n[r]-=e;t.data=n,this.time-=e},l.setPoint=function(e,t){t=t||0;var n=this.maxCount;if(t<n){var r=1+t,i=4*r,a=this.geometry,o=r>this.maxParticleBufferCount,f=this.particleCount>0?2:1,s={aPos:new Float32Array(12),aVel:new Float32Array(12),aColor:new Float32Array(16),aRot:new Float32Array(12),aOffset:new Float32Array(16),aTime:new Float32Array(8),aSeed:new Float32Array(4)};this._useSprite&&(s.aSprite=new Float32Array(12));var l,c=[[0,0],[0,1],[1,0],[1,1]],d=[],v=[0,1,0,1],m=e.pos,_=e.vel.slice(),E=e.color,p=[e.delay,e.lifetime],h=e.rot||[0,0,0];this._useSprite&&(l=e.sprite);for(var y=$e[this.particleOrigin],R=Math.random(),C=0;C<4;C++){var T=c[C];s.aPos.set(m,3*C),s.aVel.set(_,3*C),s.aColor.set(E,4*C),s.aRot.set(h,3*C),s.aTime.set(p,2*C),s.aSeed[C]=R,this._useSprite&&s.aSprite.set(l,3*C);var g=e.uv||v;g?(d[0]=g[0]/g[1]+T[0]/g[1],d[1]=g[2]/g[3]+T[1]/g[3]):(d[0]=T[0],d[1]=T[1]);var x=C+C;d[2]=y[x]*e.size[0],d[3]=y[x+1]*e.size[1],s.aOffset.set(d,4*C)}var O=new Uint32Array([0,1,2,2,1,3].map((function(e){return e+4*t})));o?(a.indices.data=ye(a.indices.data,6*r,f,6*n),a.indices.data.set(O,6*t),this.maxParticleBufferCount=a.indices.data.length/6):a.indices.setSubData(6*t,O),u(s,(function(e,r){if(o){var u=a[r];u.data=ye(u.data,i*u.size,f,4*n*u.size),u.data.set(e,e.length*t)}else a[r].setSubData(e.length*t,e)})),this.particleCount=Math.max(r,this.particleCount),a.vertexCount=6*this.particleCount}return this},l.destroy=function(t,n){e.prototype.destroy.call(this,t,n),he(this,n)},l.onUpdate=function(e){pe()},i=r,(a=[{key:"sprite",set:function(e){e&&e.animate&&(this.uSprite=new Float32Array([e.col,e.row,e.total,e.blend?1:0]),this._useSprite=!0)}},{key:"acceleration",set:function(e){this.uAcceleration=new Float32Array([e[0],e[1],e[2],4===e.length?e[3]:1])}}])&&Ke(i.prototype,a),o&&Ke(i,o),r}(m.Mesh),$e=((We={})[ve.PARTICLE_ORIGIN_CENTER]=Je(0,0),We[ve.PARTICLE_ORIGIN_CENTER_BOTTOM]=Je(0,.5),We[ve.PARTICLE_ORIGIN_CENTER_TOP]=Je(0,-.5),We[ve.PARTICLE_ORIGIN_LEFT_TOP]=Je(.5,-.5),We[ve.PARTICLE_ORIGIN_LEFT_CENTER]=Je(.5,0),We[ve.PARTICLE_ORIGIN_LEFT_BOTTOM]=Je(.5,.5),We[ve.PARTICLE_ORIGIN_RIGHT_CENTER]=Je(-.5,0),We[ve.PARTICLE_ORIGIN_RIGHT_BOTTOM]=Je(-.5,.5),We[ve.PARTICLE_ORIGIN_RIGHT_TOP]=Je(-.5,-.5),We);function Je(e,t){for(var n=[-.5,.5,-.5,-.5,.5,.5,.5,-.5],r=0;r<8;r+=2)n[r]+=e,n[r+1]+=t;return n}var Qe=function(){function e(e){this.time=e.time||0,this.interval=e.interval||1,this.count=Z(e.count),this.cycles=e.cycles||1/0,this.probability=isNaN(e.probability)?1:+e.probability,this.reset(0)}var t=e.prototype;return t.getGeneratorOptions=function(e,t){var n=e-this.time-this._now,r=this.interval;if(n>r*this._i&&this._cycles>0)return this._cycles--,this._i++,Math.random()<=this.probability?{index:this._i,total:1/r,count:this.count.getValue(t),cycleIndex:this.cycles-this._cycles-1}:null},t.reset=function(){this._cycles=this.cycles,this._i=0,this._now=0},e}(),et=n(9),tt=n.n(et);function nt(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var rt={isDependMesh:!0,get:me},it={isDependMesh:!0,get:Te},at={isDependMesh:!0,get:function(e,t,n){return m.semantic.handlerTexture(e[n.name],n.textureIndex)}},ot=function(e){var t,n;function r(t){var n,r={curves:[],index:0,max:0,lineSegCount:0,curveCount:0},i=Ye("maxVertexTextures")>0?"#define ENABLE_VERTEX_TEXTURE 1\n":"",a=0;t.colorOverLifetime&&(i+="#define COLOR_OVER_LIFETIME\n",a|=1),t.colorOverTrail&&(i+="#define COLOR_OVER_TRAIL\n",a|=4);var o=t.widthOverTrail.toUniform(r);i+="#define CURVE_VALUE_COUNT "+r.index+"\n",i+="#define MAX_KEY_FRAME_COUNT "+r.max+"\n",r.lineSegCount&&(i+="#define USE_LINE_SEG\n"),r.curveCount&&(i+="#define USE_CURVE_VALUE\n");var u=new m.ShaderMaterial({vs:i+tt.a,fs:i+Ne.a,renderOrder:t.order,shaderCacheId:"t+"+a+"+"+r.index+"+"+r.max,uniforms:{uModel:{isDependMesh:!0,get:function(e){return e.matrix.elements}},uViewProjection:"VIEWPROJECTION",uCameraDir:Ee(),uParams:it,uColorParams:it,uTime:it,uColorOverLifetime:at,uVCurveValues:it,uMaskTex:at,uWidthOverTrail:it,uColorOverTrail:at,uOpacityOverLifetimeValue:it},attributes:{aPos:rt,aDir:rt,aInfo:rt,aColor:rt,aTrailStart:rt,aSeed:rt},transparent:!0,cullFace:!1,depthMask:!1,depthTest:!0,castShadows:!1}),f=t.pointCountPerTrail*t.maxTrailCount*2,s=(t.pointCountPerTrail-1)*t.maxTrailCount,l=new m.Geometry({isStatic:!1,mode:m.constants.TRIANGLES,aPos:new m.GeometryData(new Float32Array(4*f),4),aDir:new m.GeometryData(new Float32Array(3*f),3),aInfo:new m.GeometryData(new Float32Array(4*f),4),aColor:new m.GeometryData(new Float32Array(4*f),4),aTrailStart:new m.GeometryData(new Float32Array(f),1),aSeed:new m.GeometryData(new Float32Array(f),1),indices:new m.GeometryData(new Uint32Array(6*s),1),vertexCount:6*s});return _e(t.blending,u),(n=e.call(this,{material:u,geometry:l,maxTrailCount:t.maxTrailCount,pointCountPerTrail:t.pointCountPerTrail,minimumVertexDistance:Math.pow(t.minimumVertexDistance||.001,2),lifetime:t.lifetime,uTime:0,uWidthOverTrail:o,uVCurveValues:oe.getAllData(r)})||this)._trailCursors=new Uint32Array(t.maxTrailCount),n.uParams=new Float32Array([0,t.pointCountPerTrail-1,t.width||.5,0]),n.uColorParams=new Float32Array([t.mask?1:0,0,t.blending===ve.BLEND_MODE_LUMINANCE_ALPHA,0]),n.uMaskTex=Re(t.mask)||Ce(),t.colorOverLifetime&&(n.uColorOverLifetime=ge(t.colorOverLifetime)),t.opacityOverLifetime?(n.uColorParams[1]=1,n.uOpacityOverLifetimeValue=t.opacityOverLifetime.toUniform(r)):n.uOpacityOverLifetimeValue=new Float32Array(4),t.colorOverTrail&&(n.uColorOverTrail=ge(t.colorOverTrail)),n}n=e,(t=r).prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n;var i,a,o,u=r.prototype;return u.addPoint=function(e,t,n){n=n||{};var r=this._trailCursors[e],i=this.pointCountPerTrail,a=this.geometry,o=i-1,u=r%i,f=(r-1)%i,s=(r-2)%i,l=this.getPoint(e,f);if(!(l&&function(e,t){for(var n=0,r=0;r<e.length;r++){var i=e[r]-t[r];n+=i*i}return n}(l,t)<this.minimumVertexDistance)){var c=e*i+u,d=a.aPos.data,v=a.aDir.data,m=a.aInfo.data,_=a.aColor.data,E=a.aTrailStart.data,p=a.aSeed.data,h=ut(l,t),y=[n.time||this.uTime,n.lifetime||this.lifetime,r],R=8*c,C=n.size||1;d.set(t,R),d.set(t,R+4),d[R+3]=.5*C,d[R+7]=-.5*C;var T=6*c;v.set(h,T),v.set(h,T+3);var g=n.color||[1,1,1,1];if(_.set(g,R),_.set(g,R+4),m.set(y,R),m.set(y,R+4),m[R+3]=0,m[R+7]=1,p[2*c+1]=p[2*c]=Math.random(),["aPos","aDir","aInfo","aColor","aTrailStart","aSeed"].forEach((function(e){return a[e].isDirty=!0})),f>=0){var x=ut(this.getPoint(e,s),l,t),O=6*(e*i+f);v.set(x,O),v.set(x,O+3);var V=e*i*2,L=[2*f,2*f+1,2*u,2*u,2*f+1,2*u+1].map((function(e){return e+V})),A=6*(e*o+(r-1)%o);a.indices.data.set(L,A),a.indices.isDirty=!0}r=++this._trailCursors[e];for(var N=this.uParams,S=N[0]=Math.max(0,r-i),U=0,I=2*i,D=e*I;U<I;U++)E[D+U]=S;N[1]=Math.max(N[1],r-1)-N[0]}},u.getPoint=function(e,t){var n=this.pointCountPerTrail;if(t>=0&&t<n){var r=8*(e*n+t),i=this.geometry.aPos.data;return[i[r],i[1+r],i[2+r]]}},u.clearAllTrails=function(){this._trailCursors=new Uint32Array(this._trailCursors.length);var e=this.geometry.indices;e.data=new Uint32Array(e.data.length)},u.reverseTime=function(e){for(var t=this.geometry.aInfo,n=t.data,r=0;r<n.length;r+=4)n[r]-=e;t.data=n,this.time-=e},u.clearTrail=function(e){if(0!==this._trailCursors[e]){var t=6*(this.pointCountPerTrail-1),n=this.geometry.indices;n.data.set(new Uint8Array(t),e*t),n.isDirty=!0,this._trailCursors[e]=0}},u.destroy=function(t,n){e.prototype.destroy.call(this,t,n),n&&he(this)},u.onUpdate=function(e){pe()},i=r,(a=[{key:"time",set:function(e){this.uTime=e}}])&&nt(i.prototype,a),o&&nt(i,o),r}(m.Mesh);function ut(e,t,n){var r;if(!e&&!n)return[0,0,0];if(e)if(n){r=_(p(E(t,e)),p(E(n,t)))}else r=E(t,e);else r=E(n,t);return p(r)}var ft=function(e){this.content=e},st=function(){function e(e){this.length=0,this._sort=e}var t=e.prototype;return t.findNodeByContent=function(e){var t=this.first;if(t)do{if(e(t.content))return t}while(t=t.next)},t._insertNode=function(e,t){var n=e.next;e.next=t,t.pre=e,t.next=n,n&&(n.pre=t)},t.shiftNode=function(e){var t=new ft(e);if(this.length++,1===this.length)return this.first=this.last=t;for(var n=this.first;n;){if(!(this._sort(n.content,t.content)<=0))return n.pre?this._insertNode(n.pre,t):(this.first=t,t.next=n,n.pre=t),t;if(!n.next)return this._insertNode(n,t),this.last=t;n=n.next}},t.pushNode=function(e){var t=new ft(e);if(this.length++,1===this.length)return this.last=this.first=t;for(var n=this.last;n;){if(!(this._sort(t.content,n.content)<=0))return this._insertNode(n,t),n===this.last&&(this.last=t),t;if(this.first===n)return n.pre=t,t.next=n,this.first=t;n=n.pre}},t.removeNode=function(e){var t=this.first;if(this.length--,t===e){var n=this.first=t.next;n&&(n.pre=null)}else if(t){var r=t.pre,i=t.next;r.next=i,i&&(i.pre=r)}e.pre=null,e.next=null},t.forEach=function(e,t){var n=this.first,r=0;if(n)do{e.call(t||this,n.content,r++)}while(n=n.next)},t.forEachReverse=function(e,t){var n=this.last,r=this.length-1;if(n)do{e.call(t||this,n.content,r--)}while(n=n.pre)},e}();function lt(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var ct=function(e){var t,n;function r(t){var n,r=t.options||{},i=t.addition||{},a=r.duration||1,o=r.gravityModifier,u=t.textureSheetAnimation,f=u?{animationDelay:Z(u.animationDelay||0),animationDuration:Z(u.animationDuration||1),cycles:Z(u.cycles||1),animate:u.animate,col:u.col,row:u.row,total:u.total||u.col*u.row}:null,s={options:{startLifetime:Z(r.startLifetime),startDelay:Z(r.startDelay||0),startSpeed:Z(r.startSpeed||0),startColor:Z(r.startColor),endBehavior:isNaN(r.endBehavior)?ve.END_BEHAVIOR_FORWARD:r.endBehavior,duration:a,looping:r.looping||!1,maxCount:r.maxCount||0,gravityModifier:Z(isNaN(o)?0:o).scaleXCoord(a),start3DRotation:!!r.start3DRotation,start3DSize:!!r.start3DSize,startTurbulence:!!r.startTurbulence,turbulence:r.startTurbulence&&[Z(r.turbulenceX).map(dt),Z(r.turbulenceY).map(dt),Z(r.turbulenceZ).map(dt)]},shape:w(t.shape),emission:{rateOverTime:Z(t.emission.rateOverTime),rateOverDistance:Z(t.emission.rateOverDistance),bursts:(t.emission.bursts||[]).map((function(e){return new Qe(e)})),burstOffsets:vt(t.emission.burstOffsets)},textureSheetAnimation:f,burstWillGeneratePoints:t.burstWillGeneratePoints||c,onEnd:t.onEnd||c,onIterate:t.onIterate||c,name:t.name};r.start3DRotation&&(s.options.startRotationX=Z(r.startRotationX||0).map(dt),s.options.startRotationY=Z(r.startRotationY||0).map(dt),s.options.startRotationZ=Z(r.startRotationZ||0).map(dt)),r.startRotation&&(s.options.startRotation=Z(r.startRotation||0).map(dt)),r.start3DSize?(s.options.startSizeX=Z(r.startSizeX),s.options.startSizeY=Z(r.startSizeY)):s.options.startSize=Z(r.startSize);var l=t.renderer||{},d={},v=t.rotationOverLifetime;v&&(v.separateAxes?(d.x=v.x&&Z(v.x).map(dt),d.y=v.y&&Z(v.y).map(dt),d.z=v.z&&Z(v.z).map(dt)):d.z=v.angularVelocity&&Z(v.angularVelocity).map(dt),d.asRotation=!!v.asRotation);var m=t.velocityOverLifetime||{},_={x:m.linearX&&Z(m.linearX),y:m.linearY&&Z(m.linearY),z:m.linearZ&&Z(m.linearZ),asMovement:m.asMovement},E={x:m.orbitalX&&Z(m.orbitalX).map(dt),y:m.orbitalY&&Z(m.orbitalY).map(dt),z:m.orbitalZ&&Z(m.orbitalZ).map(dt),center:m.orbCenter,asRotation:m.asRotation},p=t.sizeOverLifetime,h=t.colorOverLifetime||{},y=l.order||0,R={filter:t.filter,name:t.name+"_$mesh",renderMode:l.renderMode||ve.RENDER_MODE_BILLBOARD,side:l.side||ve.SIDE_BOTH,sizeOverLifetime:p&&{separateAxes:p.separateAxes,x:Z(p.separateAxes?p.x:p.size),y:Z(p.separateAxes?p.y:p.size)},colorOverLifetime:{color:h.color&&W(h.color),opacity:h.opacity&&Z(h.opacity)},gravityModifier:s.options.gravityModifier,gravity:r.gravity||[0,0,0],duration:r.duration,blending:l.blending||ve.BLEND_MODE_ALPHA,rotationOverLifetime:d,linearVelOverLifetime:_,orbitalVelOverLifetime:E,order:y,previewBorder:i.usePreviewBorder&&Y(W(i.borderColor),!0),particleOrigin:l.particleOrigin||ve.PARTICLE_ORIGIN_CENTER,particleLastingTime:r.endBehavior===ve.END_BEHAVIOR_FORWARD?r.duration:0,sprite:f,occlusion:!!l.occlusion,maxCount:r.maxCount},C=l.texture;!C&&u&&(C=u.texture),R.mask=Re(C,{clamp:!f})||Ce();var T=[];if(f&&!f.animate)for(var g=0;g<f.col;g++)for(var x=0;x<f.row;x++)T.push([g,f.col,x,f.row]);else T.push([0,1,0,1]);s._uvs=T,s.particleMesh=new qe(R);var O=t.trails;O&&(s.trails={lifetime:Z(O.lifetime),dieWithParticles:!1!==O.dieWithParticles,sizeAffectsWidth:O.sizeAffectsWidth,sizeAffectsLifetime:O.sizeAffectsLifetime,inheritParticleColor:O.inheritParticleColor},s.trailMesh=new ot({colorOverLifetime:W(O.colorOverLifetime),minimumVertexDistance:O.minimumVertexDistance||.02,maxTrailCount:r.maxCount,pointCountPerTrail:O.maxPointPerTrail||32,blending:l.trailBlending,mask:Re(l.trailTexture),opacityOverLifetime:O.opacityOverLifeTime&&Z(O.opacityOverLifeTime),widthOverTrail:Z(O.widthOverTrail||1),colorOverTrail:W(O.colorOverTrail),order:y,lifetime:O.lifetime})),n=e.call(this,s)||this;var V=t.transform||{},L=V.position;L&&n.setPosition(L[0],L[1],L[2]);var A=V.rotation;A&&n.setRotation(A[0],A[1],A[2]);var N=V.scale;return N&&n.setScale(N[0],N[1],N[2]),n.updateMatrixWorld(!0),n}n=e,(t=r).prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n;var i,a,o,u=r.prototype;return u.addTo=function(t){return this.particleMesh.addTo(t),this.trailMesh&&this.trailMesh.addTo(t),e.prototype.addTo.call(this,t)},u.removeFromParent=function(){return this.particleMesh.removeFromParent(),this.trailMesh&&this.trailMesh.removeFromParent(),e.prototype.removeFromParent.call(this)},u.start=function(){return this._started&&!this._ended||(this.reset(),this._started=!0,this._ended=!1),this},u.stop=function(){this._ended=!0,this._started=!1},u.burstWillGeneratePoints=function(e,t){},u.reset=function(){return this.particleMesh.clearPoints(),this.trailMesh&&this.trailMesh.clearAllTrails(),this._lastUpdate=this._loopStartTime=0,this._lastEmitTime=-1/this.emission.rateOverTime.getValue(0),this._info={generatedCount:0},this._paricleLink=new st((function(e,t){return e[0]-t[0]})),this.emission.bursts.forEach((function(e){return e.reset()})),this},u.onUpdate=function(e){var t=this;if(this._started&&!this._paused){var n=this._lastUpdate+e/1e3,r=this.particleMesh,i=this.trailMesh,a=this.options,o=this._loopStartTime;this._lastUpdate=n;var u=this.emission;if(r.time=n,i&&(i.time=n),!this._ended){var f=this.timePassed,s=a.duration,l=this.lifetime,c=this.trails;if(f<=s){for(var d=1/u.rateOverTime.getValue(l),v=Math.floor((f-this._lastEmitTime)/d),m=d/v,E=n,p=a.maxCount,h=(n-o)/a.duration,y=this._paricleLink,R=function(){var e=y.first;return y.length===p&&e&&e.content[0]-o>f},C=0;C<v&&C<p&&!R();C++){var T=this.createPoint(l);T.delay+=E+C*m,this._addParticle(T,p),this._lastEmitTime=f}for(var g=u.bursts,x=0,O=0;x<g.length&&O<p&&!R();x++){var V=g[x].getGeneratorOptions(f,l);if(V){this.burstWillGeneratePoints(x,V.cycleIndex);for(var L=(u.burstOffsets[x]||[])[V.cycleIndex]||[0,0,0],A=0;A<V.count&&O<p&&!R();A++){var N=this.initPoint(this.shape.generate({total:V.total,index:V.index,burstIndex:A/V.count}));N.delay+=E,O++,N.pos=_(N.pos,L),this._addParticle(N,p)}}}c&&y.forEach((function(e){var n=e[0],r=e[1];n<f?t.clearPointTrail(r):t.updatePointTrail(r,h)}))}else if(a.looping)n-=s,this._loopStartTime=n,this._lastEmitTime-=s,this._lastUpdate-=s,r.time-=s,u.bursts.forEach((function(e){return e.reset()})),r.reverseTime(s),i&&i.reverseTime(s),this._paricleLink.forEach((function(e){return e[0]-=s})),this.onIterate(this);else{for(var S=0;S<r.particleCount;S++)this.clearPointTrail(S);this._ended=!0,this.onEnd(this);var U=this.options.endBehavior;U===ve.END_BEHAVIOR_PAUSE?this._paused=!0:U===ve.END_BEHAVIOR_DESTROY&&this._onDestroy(this)}}}},u._onDestroy=function(e){},u._addParticle=function(e,t){var n,r=this._paricleLink,i=[e.delay+e.lifetime];if(r.length<t)n=i[1]=r.length;else{var a=r.first;r.removeNode(a),n=i[1]=a.content[1]}r.pushNode(i),this.particleMesh.setPoint(e,n),this.clearPointTrail(n)},u.clearPointTrail=function(e){this.trails&&this.trails.dieWithParticles&&this.trailMesh.clearTrail(e)},u.updatePointTrail=function(e,t){var n=this.trails,r=this.particleMesh,i=r.getPointPosition(e,this.options.gravityModifier),a=n.inheritParticleColor&&r.getPointColor(e),o=1,u=n.lifetime.getValue(t);n.sizeAffectsWidth&&(o*=r.getPointSize(e)),n.sizeAffectsLifetime&&(u*=r.getPointSize(e)),this.trailMesh.addPoint(e,i,{color:a,lifetime:u,size:o,time:r.getPointStartTime(e)})},u.onEnd=function(){},u.onIterate=function(){},u.initPoint=function(e){var t,n,r,i,a,o,u=this.options,f=this.lifetime,s=u.startSpeed.getValue(f),l=this.worldMatrix.elements,c=(t=e.position,n=l,r=t[0],i=t[1],a=t[2],o=(o=n[3]*r+n[7]*i+n[11]*a+n[15])||1,[(n[0]*r+n[4]*i+n[8]*a+n[12])/o,(n[1]*r+n[5]*i+n[9]*a+n[13])/o,(n[2]*r+n[6]*i+n[10]*a+n[14])/o]),d=p(function(e,t){var n=e[0],r=e[1],i=e[2],a=t[3]*n+t[7]*r+t[11]*i+t[15]||1;return[(t[0]*n+t[4]*r+t[8]*i)/a,(t[1]*n+t[5]*r+t[9]*i)/a,(t[2]*n+t[6]*r+t[10]*i)/a]}(e.direction,l));u.startTurbulence&&(d=p(y(d,C(u.turbulence.map((function(e){return e.getValue(f)}))))));var v,m=!1,_=this.textureSheetAnimation;_&&_.animate&&(m=[_.animationDelay.getValue(f),_.animationDuration.getValue(f),_.cycles.getValue(f)]),u.start3DRotation?v=[u.startRotationX.getValue(f),u.startRotationY.getValue(f),u.startRotationZ.getValue(f)]:u.startRotation&&(v=[0,0,u.startRotation.getValue(f)]);var E,R,T,g,x,O=u.startColor.getValue(f);if(3===O.length&&(O[3]=1),u.start3DSize)E=[u.startSizeX.getValue(f),u.startSizeY.getValue(f)];else{var V=u.startSize.getValue(f);E=[V,V]}return{vel:h(d,s),color:O,pos:c,delay:u.startDelay.getValue(f),lifetime:u.startLifetime.getValue(f),size:E,uv:(R=this._uvs,T=!0,g=Math.floor(Math.random()*R.length),x=R[g],T||R.splice(g,1),x),sprite:m,rot:v}},u.createPoint=function(e){var t={total:this.emission.rateOverTime.getValue(e),index:this._info.generatedCount,burstIndex:0};return this._info.generatedCount++,this.initPoint(this.shape.generate(t))},u.destroy=function(t,n){e.prototype.destroy.call(this,t,n),this.particleMesh.removeFromParent(),this.particleMesh.destroy(t,n);var r=this.trailMesh;r&&(r.removeFromParent(),r.destroy(t,n))},i=r,(a=[{key:"timePassed",get:function(){return this._lastUpdate-this._loopStartTime}},{key:"lifetime",get:function(){return this.timePassed/this.options.duration}}])&&lt(i.prototype,a),o&&lt(i,o),r}(m.Node);function dt(e){return e*k}function vt(e){var t={};return Array.isArray(e)&&e.forEach((function(e){var n=e instanceof Array,r=n?e[0]:e.index,i=t[r];i||(i=t[r]=[]),n?i.push(e.slice(1,4)):i.push([+e.x,+e.y,+e.z])})),t}var mt=function(){function e(e,t){var n=this;this._destroyParticleItem=function(e){n.renderer.destroyRenderNode(e)},r(this,{delay:0},e),this.renderer=t,this.items=e.items||[],e.particle?this.endBehavior=e.particle.options.endBehavior||ve.END_BEHAVIOR_DESTROY:this.endBehavior=e.endBehavior||ve.END_BEHAVIOR_DESTROY}var t=e.prototype;return t.start=function(){return this._started||(this._started=!0,this._delaying=!0,this._time=0,this._ended=!1),this},t.restart=function(){this.stop(),this.start()},t.precompile=function(){var t=this,n=this.particle;return n&&(this._particleStystem=new ct(n)),this._items=this.items.map((function(n){return new e(n,t.renderer)})),this.getMaterials()},t.getMaterials=function(){var e=this._particleStystem;if(e){var t=[e.particleMesh.material];return e.trailMesh&&t.push(e.trailMesh.material),t}},t.stop=function(){this._particleStystem&&this._particleStystem.stop(),this._items&&this._items.forEach((function(e){return e.stop()})),this._started=!1},t._reset=function(){var e=this.renderer;this._particleStystem&&(e.destroyRenderNode(this._particleStystem),this._particleStystem=null),this._model&&(e.destroyRenderNode(this._model),this._model=null),this._items&&(this._items.forEach((function(e){return e.destroy()})),this._items=null),this._started=!1},t.destroy=function(){this._reset(),this.onUpdate=function(){return-1}},t.onUpdate=function(t){if(this._started){var n=(this._time+=t/1e3)-this.delay;if(this._delaying&&n>0){this._delaying=!1;var r=this.particle,i=this.renderer,a=this.model;if(r){this._particleStystem||(this._particleStystem=new ct(r));var o=this._particleStystem;o.name=this.name,o.parent||i.addRenderNode(o),o.start(),o._onDestroy=this._destroyParticleItem}if(a&&!this._model){var u=this._model=i.createRenderNode(a);u.name=this.name,i.addRenderNode(u)}this._items||(this._items=this.items.map((function(t){return new e(t,i)}))),this._items.forEach((function(e){return e.start()}))}if(!this._delaying){if(n>this.duration){if(this.looping)return this.restart();var f=this.endBehavior;if(f===ve.END_BEHAVIOR_DESTROY)return this.destroy();f!==ve.END_BEHAVIOR_PAUSE&&f!==ve.END_BEHAVIOR_PAUSE_AND_DESTROY||(f===ve.END_BEHAVIOR_PAUSE_AND_DESTROY?this.onUpdate=this.destroy:this.endBehavior=ve.END_BEHAVIOR_FORWARD,this.renderer.pausePlayer(this))}this._items&&(this._items=this._items.filter((function(e){return-1!==e.onUpdate(t)})))}}},e}(),_t=1,Et=function(){function e(e){this.canvas=e,this.tickers=[],this.ticker=new m.Ticker(60),this._camera=new m.PerspectiveCamera({aspect:1,fov:60,far:20,near:2,z:8}),this.unsedNodes=[],this._shaderCachePrefix=_t++,this.shaderInfo={}}var t=e.prototype;return t.init=function(){this.resize();var e=this.canvas,t=e.width,n=e.height;this._camera.aspect=t/n;var r=this.stage=new m.Stage({canvas:e,camera:this._camera,pixelRatio:window.devicePixelRatio||1,clearColor:new m.Color(0,0,0,0),width:t,height:n,alpha:!0,antialias:!0});new m.AmbientLight({color:new m.Color(1,1,1,1)}).addTo(this.stage),this.ticker.addTick(this),this.ticker.start(),this.sceneNode=new m.Node({name:"root"}),this.sceneNode.addTo(this.stage);var i=r.renderer.clear;return r.renderer.clear=function(){var e=this.renderList;e.opaqueList.length+e.transparentList.length&&i.apply(this,arguments)},r.tick(0),this},t.setCamera=function(e){var t;if(e instanceof m.Camera)t=this._camera=this.stage.camera=e;else{(t=this._camera).near=e.near||2,t.far=e.far||20,t.fov=e.fov||60;var n=e.position;n&&t.setPosition(n[0],n[1],n[2])}var r=this.canvas;t.aspect=r.width/r.height,t.right&&(t.top=t.right/t.aspect,t.bottom=-t.top)},t.onResize=function(){this.resize(),this.stage&&this.stage.resize(this.canvas.width,this.canvas.height)},t.resizeToAspect=function(e){this.displayAspect=e,this.onResize()},t.resize=function(){var e=this.canvas,t=this.canvas.parentElement,n=this.displayAspect;n?t.clientWidth/t.clientHeight>n?(e.height=t.clientHeight,e.width=e.height*n):(e.width=t.clientWidth,e.height=e.width/n):(e.width=t.clientWidth,e.height=t.clientHeight);this._camera.aspect=e.width/e.height},t.addNode=function(e){e.addTo(this.sceneNode)},t.reset=function(e){this._vfxItem&&(this._vfxItem.destroy(),this._vfxItem=null);var t=this.sceneNode;t&&this.destroyRenderNode(t),this.stage.addChild(this.sceneNode=new m.Node({name:"root"})),this._vfxItem=e,this.tickers=[]},t.playVFXItem=function(e,t){this.stage||this.init();var n=new mt(e,this).start();!1!==t&&function e(t,n,r){var i=t.precompile();if(i)for(var a=0;a<i.length;a++){var o=i[a],u=o.shaderCacheId=r._shaderCachePrefix+":"+o.shaderCacheId,f=m.Shader.getCustomShader(o.vs,o.fs,"",u);f.alwaysUse=!0,m.Program.getProgram(f,r.stage.renderer.state).alwaysUse=!0,n[u]?n[u]++:n[u]=1}t._items.forEach((function(t){return e(t,n,r)}))}(n,this.shaderInfo,this),this.reset(n)},t.destroyRenderNode=function(e){e&&function(e,t){if(-1===e.indexOf(t))e.push(t)}(this.unsedNodes,e)},t.pause=function(){this.ticker.pause(),this._paused=!0},t.resume=function(){this.ticker.resume()},t.addRenderNode=function(e){e.addTo(this.sceneNode)},t.tick=function(e){if(this._paused)this._paused=!1;else{e=Math.min(e,33),this.tickers.forEach((function(t){return t.tick(e)}));var t=this._vfxItem;t&&t.onUpdate(e);var n=this.stage;n.traverseUpdate(e);var r=this.stage.renderer;this.unsedNodes.forEach((function(e){e.destroy(r,!0),e.removeFromParent()})),this.unsedNodes=[];var i=this.sceneNode;i&&i.children.length&&r.render(n,n.camera,!0)}},t.addTicker=function(e){this.tickers.includes(e)||this.tickers.push(e)},t.removeTicker=function(e){o(this.tickers,e)},t.destroy=function(){this.reset(),this.ticker.stop(),this.stage&&(this.stage.destroy(),u(this.shaderInfo,(function(e,t){var n=m.Shader.cache.get(t);if(n){var r=m.Program.cache.get(n.id);n.destroy(),r.destroy()}})),this.shaderInfo={})},e}();function pt(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var ht=function(){function e(e){var t=this;this.pausePlayer=function(e){t.pause(),t.onPausedByItem({name:e.name,player:t})},this.createRenderNode=function(e){var n=t._gltfMap[e.gltf],r=n.node;if(e.replaceCamera){var i=n.cameras[0];if(t.renderer.setCamera(i),i){if(!e.root)return null;for(r=i.parent;r&&e.root!==r.name;)r=r.parent}}else{if(!e.root)return null;r=r.getChildByName(e.root).clone()}var a=e.position;a&&r.setPosition(a[0],a[1],a[2]);var o=e.scale;o&&r.setScale(o[0],o[1],o[2]);var u=e.rotation;return u&&r.setRotation(u[0],u[1],u[2]),r};var n=e.container;n.innerHTML="<canvas></canvas>";var r=this.renderer=new Et(i("canvas",n));r.ticker.addTick(this),f(e.onPlayableUpdate)&&(this.onPlayableUpdate=e.onPlayableUpdate),r.pausePlayer=this.pausePlayer,f(e.onPausedByItem)&&(this.onPausedByItem=e.onPausedByItem),f(e.createRenderNode)?r.createRenderNode=e.createRenderNode:r.createRenderNode=this.createRenderNode,this._gltfMap={}}var t,n,a,o=e.prototype;return o.tick=function(e){if(this.onPlayableUpdate){var t=this.renderer._vfxItem;t&&this.onPlayableUpdate({player:this,playing:!0,time:t._time,name:t.name,duration:t.duration,started:t._started})}},o.loadSceneAsync=function(e,t){var n=this;return this._gltfMap={},yt(e,r({},t)).then((function(e){return n.prepareSceneAsync(e).then((function(){return e}))}))},o.prepareSceneAsync=function(e){for(var t=this,n=e.gltf||[],r=[],i={},a=function(e){var a=n[e];t._gltfMap[a]?i[a]=t._gltfMap[a]:(i[a]=(new m.GLTFLoader).load({src:a}).then((function(e){return i[a]=e})),r.push(i[a]))},o=0;o<n.length;o++)a(o);return this._gltfMap=i,Promise.all(r)},o.play=function(e,t){t=t||{},e.renderLevel=t.renderLevel;var n=e.compositionId;if(t.compositionName){var r=e.compositions.find((function(e){return e.name===t.compositionName}));if(!r)throw Error("invalid composition name");n=r.id}var i=Rt(e.compositions,n,null,e);isNaN(i.endBehavior)&&(i.endBehavior=ve.END_BEHAVIOR_PAUSE),e.camera&&this.renderer.setCamera(e.camera),this.renderer.playVFXItem(i,t.precompile),this.renderer.resume()},o.resizeToAspect=function(e){this.renderer.resizeToAspect(e)},o.pause=function(){this.renderer.pause(),this.onPlayableUpdate({player:this,playing:!1})},o.resume=function(){this.renderer.resume(),this.onPlayableUpdate({player:this,playing:!0})},o.onPlayableUpdate=function(){},o.onPausedByItem=function(){},o.destroy=function(){this._gltfMap={},this.renderer.destroy()},t=e,(n=[{key:"hasPlayable",get:function(){return!!this.renderer._vfxItem}}])&&pt(t.prototype,n),a&&pt(t,a),e}();function yt(e,t){if(t=t||{},l(e))return v(e=new URL(e,location.href).href).then(i);if(s(e)){var n=e;return e=location.href,i(n)}return Promise.reject("fail to load scene");function i(n){return Promise.all((n.images||[]).map((function(n){return l(n)?a(new URL(n,e).href):s(n)&&n.url&&n.template?Oe(new URL(n.url,e).href,n.template,t.variables,document.createElement("canvas")):Promise.resolve(n)}))).then((function(e){return r({},n,{images:e.map((function(e){return Re(e)}))})}))}}function Rt(e,t,n,r){var i=function(e,t){return e.find((function(e){return e.id===t}))}(e,t);if(!i)throw Error("invalid composition id:"+t);var a,o=i.endBehavior,u=n?n.options:i.options;u&&(o=u.endBehavior,a=u.looping);var f=r.renderLevel,s=[];return i.items.forEach((function(t){var i,a=(t.particle||t.config||t.model).options;if(Object(ve.passRenderLevel)(a&&a.renderLevel,f)){var o=t.refId;if(Number.isInteger(o))i=Rt(e,t.refId,Ct(t.config,n),r);else if(t.model){i={model:t.model,duration:t.options.duration};var u=t.model;Number.isInteger(u.gltf)&&(u.gltf=r.gltf[u.gltf])}else{var l=(i={particle:Ct(t.particle,n,["options"])}).particle.renderer;l&&["texture","trailTexture"].forEach((function(e){var t=l[e];Number.isInteger(t)&&(l[e]=r.images[t])}))}i.name=t.name,i.delay=t.delay||0,s.push(i)}})),{duration:i.duration,name:i.name,endBehavior:o,looping:a,items:s}}function Ct(e,t,n){e=e||{},t=t||{};var r={},i=Object.keys(e),a=Object.keys(t),u=s(t);return n=n||[],i.forEach((function(i){var f=e[i];if(-1===n.indexOf(i))if(u&&t.hasOwnProperty(i)){var l=t[i];Array.isArray(f)?r[i]=f.map((function(e,t){return e+l[t]})):s(f)?r[i]=Ct(f,l):r[i]=f+l,o(a,i)}else r[i]=f;else r[i]=f})),a.forEach((function(e){return-1===n.indexOf(e)&&(r[e]=t[e])})),r}n.d(t,"ParticleSystem",(function(){return ct})),n.d(t,"TrailMesh",(function(){return ot})),n.d(t,"ArcModeRandom",(function(){return N})),n.d(t,"ArcModeBurstSpread",(function(){return I})),n.d(t,"ArcModePingPong",(function(){return U})),n.d(t,"ArcModeLoop",(function(){return S})),n.d(t,"RENDER_MODE_BILLBOARD",(function(){return ve.RENDER_MODE_BILLBOARD})),n.d(t,"RENDER_MODE_VERTICAL_BILLBOARD",(function(){return ve.RENDER_MODE_VERTICAL_BILLBOARD})),n.d(t,"RENDER_MODE_HORIZONTAL_BILLBOARD",(function(){return ve.RENDER_MODE_HORIZONTAL_BILLBOARD})),n.d(t,"RENDER_MODE_MESH",(function(){return ve.RENDER_MODE_MESH})),n.d(t,"BLEND_MODE_ADDITIVE",(function(){return ve.BLEND_MODE_ADDITIVE})),n.d(t,"BLEND_MODE_ALPHA",(function(){return ve.BLEND_MODE_ALPHA})),n.d(t,"BLEND_MODE_MULTIPLY",(function(){return ve.BLEND_MODE_MULTIPLY})),n.d(t,"BLEND_MODE_LUMINANCE_ALPHA",(function(){return ve.BLEND_MODE_LUMINANCE_ALPHA})),n.d(t,"BLEND_MODE_SUBTRACT",(function(){return ve.BLEND_MODE_SUBTRACT})),n.d(t,"PARTICLE_ORIGIN_CENTER",(function(){return ve.PARTICLE_ORIGIN_CENTER})),n.d(t,"PARTICLE_ORIGIN_LEFT_TOP",(function(){return ve.PARTICLE_ORIGIN_LEFT_TOP})),n.d(t,"PARTICLE_ORIGIN_LEFT_CENTER",(function(){return ve.PARTICLE_ORIGIN_LEFT_CENTER})),n.d(t,"PARTICLE_ORIGIN_LEFT_BOTTOM",(function(){return ve.PARTICLE_ORIGIN_LEFT_BOTTOM})),n.d(t,"PARTICLE_ORIGIN_CENTER_TOP",(function(){return ve.PARTICLE_ORIGIN_CENTER_TOP})),n.d(t,"PARTICLE_ORIGIN_CENTER_BOTTOM",(function(){return ve.PARTICLE_ORIGIN_CENTER_BOTTOM})),n.d(t,"PARTICLE_ORIGIN_RIGHT_TOP",(function(){return ve.PARTICLE_ORIGIN_RIGHT_TOP})),n.d(t,"PARTICLE_ORIGIN_RIGHT_CENTER",(function(){return ve.PARTICLE_ORIGIN_RIGHT_CENTER})),n.d(t,"PARTICLE_ORIGIN_RIGHT_BOTTOM",(function(){return ve.PARTICLE_ORIGIN_RIGHT_BOTTOM})),n.d(t,"END_BEHAVIOR_DESTROY",(function(){return ve.END_BEHAVIOR_DESTROY})),n.d(t,"END_BEHAVIOR_PAUSE",(function(){return ve.END_BEHAVIOR_PAUSE})),n.d(t,"END_BEHAVIOR_FORWARD",(function(){return ve.END_BEHAVIOR_FORWARD})),n.d(t,"END_BEHAVIOR_PAUSE_AND_DESTROY",(function(){return ve.END_BEHAVIOR_PAUSE_AND_DESTROY})),n.d(t,"FILTER_NAME_NONE",(function(){return ve.FILTER_NAME_NONE})),n.d(t,"RENDER_LEVEL_B_PLUS",(function(){return ve.RENDER_LEVEL_B_PLUS})),n.d(t,"RENDER_LEVEL_B",(function(){return ve.RENDER_LEVEL_B})),n.d(t,"RENDER_LEVEL_A_PLUS",(function(){return ve.RENDER_LEVEL_A_PLUS})),n.d(t,"RENDER_LEVEL_A",(function(){return ve.RENDER_LEVEL_A})),n.d(t,"RENDER_LEVEL_S",(function(){return ve.RENDER_LEVEL_S})),n.d(t,"SIDE_BOTH",(function(){return ve.SIDE_BOTH})),n.d(t,"SIDE_FRONT",(function(){return ve.SIDE_FRONT})),n.d(t,"SIDE_BACK",(function(){return ve.SIDE_BACK})),n.d(t,"passRenderLevel",(function(){return ve.passRenderLevel})),n.d(t,"VFXItem",(function(){return mt})),n.d(t,"setGLStatus",(function(){return Ge})),n.d(t,"setReporter",(function(){return Ze})),n.d(t,"MarsPlayer",(function(){return ht})),n.d(t,"loadSceneAsync",(function(){return yt})),n.d(t,"getVFXItem",(function(){return Rt})),n.d(t,"combineImageTemplateAsync",(function(){return Oe})),n.d(t,"imageDataFromGradient",(function(){return b})),console.log("Mars Player version: 0.0.43")}])}));
//# sourceMappingURL=index.js.map